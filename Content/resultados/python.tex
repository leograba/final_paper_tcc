Nesta seção são apresentados os resultados e discussões referentes ao registro de temperatura em arquivo CSV e ao gráfico gerado em Python.

\subsection{Registro de temperatura}
\label{temp_py_res}

Na figura \ref{csv_log_example} é apresentada uma amostra de arquivo CSV gerado pelo script \ref{tlog_log}, e que valida o funcionamento da aplicação.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/csv_log_example.jpg}
	\captionsetup{justification=centering}
	\caption[Arquivo CSV com registro de temperaturas gerado em Python]{Arquivo CSV com registro de temperaturas gerado em Python}
	\label{csv_log_example}
\end{figure}

Observa-se a partir deste que o tempo de amostragem, mesmo após o estudo do apêndice \ref{analise_tread_temp}, tem média cujo valor foi de 1,008s, diferente dos 1s desejados. Ainda assim, é preciso ressaltar que este valor está sujeito a mudanças em função da carga do sistema, o que significa que a diferença de 8ms do tempo médio não seria eliminada durante a execução da aplicação de controle do processo de produção de cerveja. Caso seja estritamente necessário para uma aplicação que o tempo de amostragem não sofra variações, deve ser cogitado o uso de um sistema operacional de tempo real, do subsistema PRU-ICSS da BBB ou de um microcontrolador auxiliar que se comunique com a BBB por meio de um barramento de comunicação.

Para confirmar o funcionamento da função que faz o registro da última temperatura lida em um arquivo separado, o comando \textit{tail} do Linux foi empregado. Na figura \ref{log_funciona} é apresentado o resultado prático desta abordagem.

\begin{figure}[H]
	\centering
	\begin{subfigure}{.46\textwidth}
		\centering
		\includegraphics[height=2.2cm]{./Resources/logpy.png}
		\caption{Script python em execução}
		\label{log_funciona:1}
	\end{subfigure}
	\begin{subfigure}{.46\textwidth}
		\centering
		\includegraphics[height=7.2cm]{./Resources/log_tailpy.png}
		\caption{Arquivo de registro da última temperatura}
		\label{log_funciona:2}
	\end{subfigure}
	\captionsetup{justification=centering}
	\caption[Conformidade da atualização do arquivo de registro da última temperatura capturada pelo script Python]{Conformidade da atualização do arquivo de registro da última temperatura capturada pelo script Python}
	\label{log_funciona}
\end{figure}

\subsection{Gráfico de temperatura}
\label{res_graph_py}

Na figura \ref{py_graph_7200p} é apresentado um gráfico que foi gerado na BBB a partir de 7200 pontos amostrados, ou seja, aproximadamente 120 minutos. Este tempo foi escolhido uma vez que dificilmente o cozimento do mosto ou a fervura dura mais do que isso, portanto provando que a implementação é factível para o uso a que se destina. A tabela  \ref{tabela_tempo_graph_python} apresenta informações estatísticas sobre o tempo de computação necessário para a geração do gráfico. A figura \ref{amostras_graph} apresenta o processo de verificação do número de pontos registrados e o posterior processo de coleta dos dados que deram origem à tabela \ref{tabela_tempo_graph_python}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{./Resources/py_graph_7200p.png}
	\captionsetup{justification=centering}
	\caption[Gráfico com 7200 pontos gerado em Python]{Gráfico com 7200 pontos gerado em Python}
	\label{py_graph_7200p}
\end{figure}

%\begin{center}
	\begin{table}[H]
		\centering
		\captionsetup{justification=centering}
		\caption[Estatísticas referentes ao tempo de geração de gráfico na BBB, para 7200 pontos em Python]{Estatísticas referentes ao tempo de geração de gráfico na BBB, para 7200 pontos em Python}
		\label{tabela_tempo_graph_python}
		\begin{tabular}{ | M{5cm} | M{2cm} |}
			\hline
			\textbf{Descrição} & \textbf{Valor} \\ \hline
			N.\si{\degree} de amostras & 30\\ \hline
			Média (s) & 2,106\\ \hline
			Máximo (s) & 2,068\\ \hline
			Mínimo (s) & 2,149\\ \hline
			Desvio padrão (s) & 0,023\\ \hline
		\end{tabular}
	\end{table}
%\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/log_py_graph_7200p.jpg}
	\captionsetup{justification=centering}
	\caption[Geração de gráfico em Python múltiplas vezes para obter o tempo médio]{Geração de gráfico em Python múltiplas vezes para obter o tempo médio}
	\label{amostras_graph}
\end{figure}

Também foi realizado um registro de temperatura durante 38 dias ininterruptos, para comprovar a robustez da aplicação de registro de temperatura, a capacidade de geração de gráfico para um número de pontos muito superior ao de uma produção de cerveja e também para comprovação do funcionamento da escala ajustável em função da logevidade do arquivo de registros. O gráfico gerado a partir deste registro é apresentado na figura \ref{graph_long} e indica a temperatura da saída de ventilação de um notebook com problemas de resfriamento.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.60]{./Resources/tplot.png}
	\captionsetup{justification=centering}
	\caption[Geração de gráfico em Python a partir de um volume elevado de dados]{Geração de gráfico em Python a partir de um volume elevado de dados}
	\label{graph_long}
\end{figure}

É importante notar que as duas aplicações escritas em Python para este projeto foram desenvolvidas em uma fase inicial, ou seja, ao longo do primeiro mês e meio deste. Isto significa que, naquele momento, o desenvolvedor não possuía conhecimentos práticos de Linux embarcado e nem mesmo de linguagens de programação de alto nível, com excessão de MATLAB. Isto foi traduzido em dois pontos que foram constatados somente muito tempo depois da escrita dos códigos Python: a curva de aprendizado de todo um sistema novo custou uma parcela significativa de tempo do projeto e; o fato de as tarefas necessárias para cumprir o projeto estarem mal definidas naquele momento inicial, levaram o desenvolvedor a usar mais tempo do que seria razoável destinar a esta tarefa.

A análise do tempo de leitura do sensor DS18B20, descrita no apêndice \ref{analise_tread_temp} comprova o resultado que se espera sabendo que o Linux não é um sistema operacional de tempo-real: o tempo de amostragem não é constante. Este é um fato já conhecido e, portanto, a análise conduzida não significa necessariamente uma contribuição inovadora. Por outro lado, esta análise levou o desenvolvedor à ideia de que talvez seja possível criar dentro do próprio script uma maneira de ajustar o tempo de amostragem a partir de valores anteriores de tal modo que o tempo médio seja o desejado, o que requer um estudo de caso e análise de aplicação: vislumbrando o fato de que o tempo de amostragem do DS18B20 é limitado pelo driver do Kernel a 750ms e que a resposta de um sistema térmico é muito lenta se comparada com um sistema eletrônico, é interessante estudar a possibilidade e os efeitos da implementação de um controlador PID ou suas variações sob as condições propostas.

Quanto ao gráfico de temperatura, seu uso ficou restrito ao início do projeto e foi relegado ao segundo plano depois da implementação do gráfico dinâmico usando D3.js e Rickshaw. O conhecimento adquirido a partir da necessidade de gerar este gráfico mostrou que a linguagem de programação Python é aliada de pesquisadores, com as bibliotecas NumPy e SciPy, dentre outras, e pode ser uma alternativa de baixo custo a soluções proprietárias como o MATLAB; por outro lado, a curva de aprendizado e, possivelmente a facilidade de consulta a documentação sejam pontos nos quais as soluções proprietárias se sobressaem. Também foi surpreendente o fato de a BBB plotar em 2,1 segundos um gráfico com 7200 pontos --- em parte a surpresa se deu pelo fato de o desenvolvedor não conhecer as limitações da plataforma que estava usando, quando foi desenvolvido o script que plota o gráfico.

O registro de temperatura de 38 dias ininterruptos mostra que a linguagem Python, na plataforma BBB, suportou criar e lidar com um arquivo de registros CSV de 3.283.200 entradas, o que representa um arquivo de 95,2MB, sabendo-se que cada entrada ocupou 29 caracteres no arquivo. Esta reflexão também levou à consideração de que deveria ter sido implementado um banco de dados, ao menos para testes.

Por fim, estes códigos ficaram legados no projeto, porém poderiam facilmente ser substituídos por módulos em Node.js, o que padrozinaria a aplicação e a tornaria mais coerente, do ponto de vista que não seria necessário executar um comando do shell a partir do Node.js para executar o script Python. Além disto, o comportamento assíncrono do Node.js possibilitaria a leitura do DS18B20, que demora 750ms, em paralelo com outras atividades nativamente, o que é um benefício não implementado no script Python.
