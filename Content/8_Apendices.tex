\chapter{\textit{Programmable Real-time Unit -- PRU-ICSS}}
\label{apendice_pru}

A PRU-ICSS -- \textit{Programmable Real-Time Unit Subsystem and Industrial Communications Subsystem} (Unidade Programável de Tempo-Real e Subsistema de Comunicação Industrial, em tradução livre) é um subsistema do processador AM3358 que equipa a BBB, fabricado pela \textit{Texas Instruments}, embora não possua suporte oficial da mesma \cite{bbb_srm}. Esta unidade consiste de dois núcleos RISC de 32 bits, uma memória compartilhada de 12kB, uma memória de dados e uma memória de programa para cada núcleo, ambas com 8kB de capacidade, e periféricos internos -- além da possibilidade de acessar todos os eventos, pinos e recursos do SoC AM3358 por meio de uma interface OCP, que confere a este subsistema grande flexibilidade. Cada núcleo da PRU pode operar independentemente ou de maneira sincronizada, dependendo de como o \textit{firmware} para eles é escrito \cite{soc_manual}. Na figura é ilustrado o diagrama de blocos deste sistema.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.40]{./Resources/pru-blockDG.png}
	\captionsetup{justification=centering}
	\caption[Diagrama de blocos do subsistema PRU-ICSS]{Diagrama de blocos do subsistema PRU-ICSS. \\Fonte: TEXAS INSTRUMENTS (2015)
	}
	\label{pru-bdg}
\end{figure}

Os núcleos da PRU foram otimizados para realizar tarefas com requisitos severos de tempo-real e, portanto, tem um \textit{clock} de 200MHz e um sistema de instruções RISC no qual todas elas são executadas em um ciclo de \textit{clock}, propositalmente sem suporte a \textit{pipelining}. Cada núcleo tem 31 registradores, cuja utilização vai de propósito geral a indexação e controle de GPIO, acessíveis a nível de bit, byte, \textit{halfword} (16 bits), \textit{word} (32 bits) ou por ponteiro \cite{soc_manual}. Uma vez que cada instrução pode ser executada em 5ns e o acesso a GPIO é feito por meio de uma única instrução de acesso a registradores, isto significa que é possível obter uma resolução de chaveamento determinística de no máximo 5ns, com dados obtidos na prática, por \cite{bbb_pulsegen}, de \textit{jitter} RMS de 290ps e estabilidade de frequência na ordem de 10 ppm.

Uma vez que as diversas funcionalidades do módulo PRU são acessadas por meio de mapeamento da memória de dados, é preciso saber a faixa de endereço destas. Aqui deve ser feita a distinção entre acesso à memória local da PRU, que compreende os endereços de 0x0000\_0000 a 0x0007\_FFFF, e o acesso à memória global, cujos endereços começam em 0x0008\_0000. Também é importante notar que as memórias internas dos módulos podem ser acessados com o endereço global de memória, mas isso reduz significativamente o tempo de acesso, já que o sinal é roteado para fora da PRU (por meio do OCP) antes de ser recebido \cite{soc_manual}. Na tabela \ref{pru_localmem} é apresentado o mapa de memória local e na tabela \ref{pru_globalmem} é apresentado o mapa de memória global. Também há uma tabela de constantes gravada em hardware, com valores de uso recorrente, para economizar instruções de programação e registradores, nos quais estes endereços precisariam ser carregados se não estivessem disponíveis em hardware \cite{soc_manual}.

Embora cada PRU suporte 30 canais de entrada e 32 canais de saída no modo direto \cite{soc_manual}, a BBB roteia somente 25 pinos do SoC ao conector de expansão. Destes, 10 pinos são exclusivos da PRU0 (8 saídas ou 9 entradas) e 15 pinos para a PRU1 (13 saídas ou 14 entradas). Eventualmente, alguns pinos pré-configurados para outras funções devem ser reconfigurados na \textit{device tree} antes que possam ser utilizados \cite{bbb_srm}. Os pinos da BBB acessíveis pela PRU podem ser obtidos na figura \ref{bbb_pins_pru}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.80]{./Resources/bbb-pins-pru.jpg}
	\captionsetup{justification=centering}
	\caption[Pinos da BeagleBone Black acessíveis pela PRU-ICSS]{Pinos da BeagleBone Black acessíveis pela PRU-ICSS. \\Fonte: Site oficial da Fundação BeagleBoard.org\protect\footnotemark
	}
	\label{bbb_pins_pru}
\end{figure}

\footnotetext{Disponível em \url{http://beagleboard.org/Support/bone101}}

\begin{center}
	\begin{table}[H]
		\captionsetup{justification=centering}
		\caption[Mapa de Memória Local da PRU]{Mapa de Memória Local da PRU. \\Fonte: adaptado de TEXAS INSTRUMENTS(2014)}
		\label{pru_localmem}
		\begin{tabular}{ | M{5cm} | M{5cm} | M{5cm} |}
			\hline
			\textbf{Endereço Inicial} & \textbf{PRU0} & \textbf{PRU1} \\ \hline
			0x0000\_0000 & Mem. dados da PRU0 & Mem. dados da PRU1\\ \hline
			0x0000\_2000 & Mem. dados da PRU1 & Mem. dados da PRU0\\ \hline
			0x0001\_0000 & Mem. dados compartilhada & Mem. dados compartilhada \\ \hline
			0x0002\_0000 & INTC & INTC \\ \hline
			0x0002\_2000 & Controle da PRU0 & Controle da PRU0 \\ \hline
			0x0002\_2400 & Reservado & Reservado \\ \hline
			0x0002\_4000 & Controle da PRU1 & Controle da PRU1 \\ \hline
			0x0002\_4400 & Reservado & Reservado \\ \hline
			0x0002\_6000 & CFG & CFG \\ \hline
			0x0002\_8000 & UART0 & UART0 \\ \hline
			0x0002\_A000 & Reservado & Reservado \\ \hline
			0x0002\_C000 & Reservado & Reservado \\ \hline
			0x0002\_E000 & IEP & IEP \\ \hline
			0x0003\_0000 & eCAP0 & eCAP0 \\ \hline
			0x0003\_2000 & Reservado & Reservado \\ \hline
			0x0003\_2400 & Reservado & Reservado  \\ \hline
			0x0003\_4000 & Reservado & Reservado  \\ \hline
			0x0003\_8000 & Reservado & Reservado  \\ \hline
			0x0004\_0000 & Reservado & Reservado  \\ \hline
			0x0008\_0000 & System OCP\_HP0 & System OCP\_HP1 \\ \hline
		\end{tabular}
	\end{table}
\end{center}

As interfaces de interrupção e de GPIO estão contidas nos registradores R30 e R31: o registrador R31 é utilizado tanto para interface dos pinos configurados como entrada quanto para leitura e/ou geração de eventos de interrupção, enquanto o registrador R30
retorna status ou muda o valor dos pinos configurados como saída, para leitura e escrita, respectivamente. Embora a entrada possa ser configurada nos modos de captura paralela de 16 bits e trem de pulsos de 28 bits, estes modos de operação não serão detalhados, já que seu uso não está previsto no escopo deste projeto. O mesmo é válido para a saída, que além do modo direto, pode ser configurada para transmitir um trem de pulsos \cite{soc_manual}.

Outra característica da PRU é a existência de um IEP - \textit{Industrial Ethernet Peripheral} (Periférico Ethernet Industrial, em tradução livre), composto de um \textit{timer} para Ethernet industrial com 8 eventos de comparação e uma porta digital de E/S. O \textit{timer} Ethernet industrial é simplesmente um temporizador de 32 bits e, portanto, pode ser utilizado para uso geral. É um contador positivo, cujo valor dos incrementos pode ser programado na faixa de 1-16, com compensador de uso opcional. Os 8 registradores comparadores permitem a criação de eventos cada vez que o valor do comparador corresponde ao do temporizador \cite{soc_manual}.

\begin{center}
	\begin{table}[H]
		\captionsetup{justification=centering}
		\caption[Mapa de Memória Global da PRU]{Mapa de Memória Global da PRU. \\Fonte: adaptado de TEXAS INSTRUMENTS(2014)}
		\label{pru_globalmem}
		\begin{tabular}{ | M{5cm} | M{10cm} |}
			\hline
			\textbf{Endereço de Offset} & PRU-ICSS \\ \hline
			0x0000\_0000 & Mem. dados da PRU0 \\ \hline
			0x0000\_2000 & Mem. dados da PRU1 \\ \hline
			0x0001\_0000 & Mem. dados compartilhada \\ \hline
			0x0002\_0000 & INTC \\ \hline
			0x0002\_2000 & Controle da PRU0 \\ \hline
			0x0002\_2400 & Debug da PRU0 \\ \hline
			0x0002\_4000 & Controle da PRU1 \\ \hline
			0x0002\_4400 & Debug da PRU1 \\ \hline
			0x0002\_6000 & CFG \\ \hline
			0x0002\_8000 & UART0 \\ \hline
			0x0002\_A000 & Reservado \\ \hline
			0x0002\_C000 & Reservado \\ \hline
			0x0002\_E000 & IEP \\ \hline
			0x0003\_0000 & eCAP0 \\ \hline
			0x0003\_2000 & Reservado \\ \hline
			0x0003\_2400 & Reservado  \\ \hline
			0x0003\_4000 & IRAM da PRU0  \\ \hline
			0x0003\_8000 & IRAM da PRU1  \\ \hline
			0x0004\_0000 & Reservado  \\ \hline
		\end{tabular}
	\end{table}
\end{center}

No que diz respeito ao desenvolvimento de \textit{firmware} para a PRU, há um conjunto de instruções RISC em assembly, suportado por um conjunto de ferramentas que ajudam a gerar o arquivo binário a ser carregado na memória de programa. Alguns exemplos são o \textit{assembler}, \textit{archiver} e o \textit{linker} \cite{pru_assembly_tools}. Outra ferramenta de desenvolvimento proporcionada pela Texas Instruments é um compilador C/C++, que facilita a programação em níveis de abstração elevados \cite{pru_compiler}. A figura \ref{pru_firmdev} apresenta um diagrama de blocos que ilustra os passos a serem executados desde compilar o código C/C++ até carregar o arquivo executável na memória de programa da PRU.

\newpage

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.80]{./Resources/pru-software-dev.png}
	\captionsetup{justification=centering}
	\caption[Fluxo de desenvolvimento de software da PRU]{Fluxo de desenvolvimento de software da PRU. \\Fonte: TEXAS INSTRUMENTS
	}
	\label{pru_firmdev}
\end{figure}

\chapter{Sensor de temperatura DS18B20}
\label{ds_apendice}

O sensor de temperatura DS18B20, projetado pela Maxim, é um sensor digital que utiliza somente um pino de dados para comunicação com o dispositivo \textit{master}, cujas regras são estabelecidas pelo protocolo proprietário de comunicação $\textit{1-Wire}^\textregistered$ \cite{ds18b20}.

\textit{1-Wire} é um protocolo de comunicação serial \textit{half-duplex} que utiliza uma linha para transmissão de dados, além da referência. Ele é do tipo \textit{master/slave}, ou seja, um dispositivo \textit{master} inicia a comunicação e os dispositivos \textit{slave} somente respondem aos seus comandos. No caso deste protocolo específico, todo dispositivo possui um identificador de 64 bits único, dentro do qual um byte indica o tipo do dispositivo. Devido ao seu modo de funcionamento, quando a linha de dados é desconectada, os dispositivos \textit{slave} entram em estado de \textit{reset}, o que favorece seu uso em aplicações de contato. Enquanto a maioria destes dispositivos tem uma faixa de alimentação de 2,80-5,25V e não possui pino para alimentação \cite{onewire_ov} -- utilizando um sistema de alimentação parasita -- o sensor DS18B20 tem a possibilidade de alimentação parasita ou não e sua faixa tolerada para funcionamento é de 3-5,5V \cite{ds18b20}.

Uma vez que este protocolo de comunicação foi concebido para operações nas quais os dispositivos \textit{master} e \textit{slave} estão fisicamente muito próximos, alguns cuidados devem ser observados ao utilizar linhas de transmissão de longas distâncias para manter a boa performance do sistema \cite{onewire_distance}. Como o estudo da Maxim acerca das implicações do uso de linhas de longa distância negligencia este aspecto para redes com poucos dispositivos e cabeamento curto (menor que 10m), os cuidados de projeto das redes \textit{1-wire} não serão aqui especificados, deixando um aviso para trabalhos futuros que visem aplicações de longas distâncias ou com número elevado de dispositivos, a exemplo de uma microcervejaria de porte industrial.

Com relação a aspectos específicos do sensor de temperatura, este apresenta precisão de 0,5\si{\degree}C para a faixa de temperaturas de -10\si{\degree}C a +85\si{\degree}C, e de 2,0\si{\degree}C para a faixa completa de operação, de -55\si{\degree}C a +125\si{\degree}C. Quanto à resolução, esta pode ser programada de 9 a 12 bits, sendo 8 bits para a parte inteira e 1 a 4 bits decimais. O custo da melhor resolução é o aumento no tempo de conversão de uma leitura para valor digital, variando de 93,75ms a 750ms para os casos extremos \cite{ds18b20}.

A arquitetura interna do CI é apresentada na figura \ref{18b_blocos}. Nota-se que o dispositivo, por utilizar o protocolo \textit{1-Wire}, tem uma ROM de 64 bits para identificação \cite{onewire_ov}, além de uma região de memória de rascunho, que consiste de uma memória SRAM de 64 bits, dividida em 8 regiões de 1 byte, para promover a interface com as funcionalidades do CI: sensor de temperatura, alarmes programáveis para estouro de valores mínimo e máximo das medições, registrador de configuração da resolução e gerador de código CRC de 8 bits \cite{ds18b20}. A figura \ref{18b_mmap} apresenta o mapa de memória do DS18B20 -- nota-se que os registradores de configuração e alarme são copiados para uma memória não volátil (EEPROM) após configurados pelo \textit{master}, retendo seus valores mesmo em caso de corte na alimentação. Outra informação útil obtida a partir da figura \ref{18b_mmap} é o valor da temperatura lido após uma queda de alimentação, que é de +85\si{\degree} C até que o dispositivo esteja pronto para uso \cite{ds18b20}.

As leituras de temperatura são feitas em dois bytes, LSB e MSB, representados na figura \ref{18b_formato}, e que juntos são uma representação em complemento de dois, sendo que os 5 bits mais significativos são redundantes e, para resoluções menores do que 12 bits, o valor dos bits menos significativos é indefinido (1 bit indefinido para 11 bits de resolução; 2 bits indefinidos para 10 bits de resolução, etc).

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{./Resources/ds18b20-blocos.png}
	\captionsetup{justification=centering}
	\caption[Arquitetura interna do DS18B20]{Arquitetura interna do DS18B20 \\Fonte: MAXIM INTEGRATED
	}
	\label{18b_blocos}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=11.83cm]{./Resources/ds18b20-mmap.png}
	\captionsetup{justification=centering}
	\caption[Mapa de memória do DS18B20]{Mapa de memória do DS18B20. \\Fonte: MAXIM INTEGRATED
	}
	\label{18b_mmap}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=11.83cm]{./Resources/ds18b20-formato.png}
	\captionsetup{justification=centering}
	\caption[Registradores de temperatura do DS18B20]{Registradores de temperatura do DS18B20. \\Fonte: MAXIM INTEGRATED
	}
	\label{18b_formato}
\end{figure}

O Kernel do Linux possui \textit{device drivers} que suportam parcialmente o uso do sensor DS18B20, portanto não há a necessidade de descrever em detalhes o protocolo \textit{1-Wire}. O \textit{device driver} \textit{w1-gpio} controla o barramento (\textit{master}) \textit{1-wire} utilizando a API GPIO para controlar a linha, sendo que a porta utilizada é especificada na descrição de hardware do sistema embarcado (\textit{device tree}) abordada na seção \ref{dt_section}. O \textit{device driver} \textit{w1-therm} suporta algumas famílias de sensores de temperatura da Maxim (\textit{slave}), dentre elas a DS18*20, fazendo conversões básicas de temperatura e fornecendo-as ao sistema por meio do FS (\textit{File System} ou Sistema de Arquivos). O resultado da abertura e leitura do arquivo correspondente a um sensor, é a conversão de temperatura pelo \textit{driver} e posterior fornecimento dos dados recebidos do sensor --- status da checagem do CRC e temperatura em \si{\degree}C/1000. Este driver não suporta conversão de temperatura simultânea de múltiplos sensores nem redução da precisão de conversão, portanto só são possíveis leituras de 12 bits, o que leva o acesso pelo FS a demorar cerca de 750ms. Em caso de alimentação parasita, somente um sensor pode estar conectado à linha por vez e, caso o sistema embarcado ofereça suporte a \textit{pull-up} interno, o driver é capaz de usá-lo \cite{onewire_kernel}.

\chapter{BeagleBone Black}
\label{bbb_apendice}

\input{./Content/materiais/bbb.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\chapter{Scripts Python}
\label{codigos_python}

\section{Módulo com as funções para \textit{log} da temperatura}
\input{./SourceCodes/temp.py.tex}

\section{Script para plotagem de gráfico}
\input{./SourceCodes/grafico.py.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\chapter{Códigos-fonte Node.js}
\label{codigos_nodejs}

\section{Código-fonte raiz da aplicação em Node.js}
\input{./SourceCodes/controle.tex}

\section{Módulo de gerenciamento de GPIO e PWM}
\input{./SourceCodes/gpio_cfg.tex}

\section{Módulo de roteamento do servidor web}
\input{./SourceCodes/routes.tex}

\section{Módulo de registros e verificações em geral}
\input{./SourceCodes/log_check_misc.tex}

\section{Módulo de controle do processo de brassagem}
\input{./SourceCodes/ctrl.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\chapter{Códigos-fonte da aplicação web}
\label{codigos_web}

\section{Módulo PHP que cria a barra de navegação da interface web}
\input{./SourceCodes/header_php.tex}

\section{Função que passa a URL da página atual para um módulo em PHP}
\input{./SourceCodes/header_js.tex}

\section{Página inicial}
\input{./SourceCodes/index.tex}

\section{Página \textit{sobre}}
\input{./SourceCodes/about.tex}

\section{Página de estatísticas}
\input{./SourceCodes/stats.tex}

\section{Gráfico dinâmico de temperatura}
\input{./SourceCodes/dyn_graph.tex}

\section{Página gerenciadora de receitas da interface web}
\input{./SourceCodes/listrecipes.tex}

\section{Funcões auxiliares do gerenciador de receitas}
\input{./SourceCodes/listrecipes_js.tex}

\section{Código HTML do editor de receitas}
\input{./SourceCodes/newrecipe.tex}

\section{Código PHP do editor de receitas}
\input{./SourceCodes/newrecipe_php.tex}

\section{Código javascript do editor de receitas}
\input{./SourceCodes/newrecipe_js.tex}

\section{Gerenciador de brassagem}
\input{./SourceCodes/startrecipe.tex}

\section{Painel de controle de brassagem}
\input{./SourceCodes/control_php.tex}

\section{CSS do formulário}
\input{./SourceCodes/form.tex}

\section{CSS específico para alguns botões}
\input{./SourceCodes/buttons.tex}

\section{CSS do template da aplicação web}
\input{./SourceCodes/config.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\chapter{Arquivos de configuração do sistema}
\label{Apêndice B}

\section{Arquivo de configuração de rede}
\input{./SourceCodes/etc-network-interfaces.tex}

\section{Device Tree para o DS18B20}
\label{ap3ds18b20}
\input{./SourceCodes/w1.dts.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\chapter{Caracterização do funcionamento do servo-motor com AT89S52}
\label{apendice_servo}

Servomotor é um dispositivo de conversão eletromecânica que surgiu da necessidade de controle de posição angular de um motor de corrente contínua --- tanto é que um servomotor é um motor DC com controle e realimentação, ou seja, um dispositivo de malha fechada. Além da tensão de alimentação, o servomotor recebe um sinal de controle proporcional à posição desejada do eixo e atua no motor DC até que, através do ramo de realimentação, atinja-se a posição angular de entrada. A Figura \ref{servo_desmontado} apresenta um servomotor desmontado e a identificação de suas partes principais.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/servo/partes.png}
	\captionsetup{justification=centering}
	\caption[Servo-motor desmontado]{Servo-motor desmontado}
	\label{servo_desmontado}
\end{figure}

Observa-se que o circuito de controle é um circuito integrado, porém não há ampla documentação acerca de sua arquitetura interna; já o potenciômentro é o elemento sensor do conjunto, cujo objetivo é fornecer a posição angular do eixo através da variação de sua resistência. O motor é a planta do sistema de controle, convertendo energia elétrica em rotação do eixo. O conjunto de engrenagens é responsável por aumentar o torque do mesmo, com a diminuição da velocidade de rotação.

A caracterização funcionamento do servomotor foi realizada em 4 partes: elaboração do código de controle para 8051; simulação no software Proteus ISIS; ensaio para determinar os valores práticos de operação do servomotor e; nova simulação no software Proteus ISIS. O código para AT89S52 --- compatível com 8051 --- é apresentado na caixa \ref{at_servo_code} do apêndice \ref{apendice_servo} e o diagrama esquemático do circuito de teste e simulação na figura \ref{circuito_servo}. O uso do AT89S52 se deve ao fato de que o uso do PWM com a BBB ainda não estava desenvolvido neste ponto do projeto, porém posteriormente a interface entre servo-motor e BBB foi realizada --- e os resultados estão descritos na seção \ref{aciona_results}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.23]{./Resources/servo/diagrama_esquematico.png}
	\captionsetup{justification=centering}
	\caption[Circuito de caracterização do servo-motor]{Circuito de caracterização do servo-motor}
	\label{circuito_servo}
\end{figure}

Observa-se a necessidade de um buffer entre o microcontrolador AT89S52 e o servomotor, pois a corrente requisitada pelo pino de controle do servo é maior do que a corrente máxima fornecida pelo \si{\micro}C. 

\section{Simulação e ensaio em bancada}

O "ciclo" referido a seguir é o mínimo incremento do tempo em alto do sinal de controle --- baseado em simulação, o código utilizado para gerar o pulso em nível alto apresentou uma limitação de período/incremento de 20\si{\micro}s para f=12MHz, portanto o código trabalha com resolução de 20us/incremento em 12MHz. Na figura \ref{servo_wave} é apresentada a forma de onda necessária para controlar o servo motor.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.30]{./Resources/servo/wave.png}
	\captionsetup{justification=centering}
	\caption[Forma de onda de acionamento do servo-motor]{Forma de onda de acionamento do servo-motor}
	\label{servo_wave}
\end{figure}

O período T é fixo, com valor de 20ms, e o tempo em nível alto $\Delta$t é de, aprioximadamente $0,5ms < \Delta t < 2,5ms$. O objetivo da caracterização do servomotor em questão foi definir com precisão os limites de $\Delta$t. Após a simulação bem-sucedida do controle do servo motor incluso na bibloteca padrão do Proteus, o código foi efetivamente gravado no \si{\micro}C AT89S52, com f=24MHz e o motor foi excursionado até seus limites --- e além deles --- e seu comportamento foi observado e documentado, conforme é apresentado na figura \ref{excursao_servo}. O led vermelho ligado mecanicamente ao braço do servo é somente uma referência visual para a posição angular deste.

\begin{figure}[H]
	\centering
	\begin{subfigure}{.48\textwidth}
		\centering
		\includegraphics[height=5.5cm]{./Resources/servo/ciclo_26.jpg}
		\caption{Limite físico inferior}
		\label{excursao_servo:1}
	\end{subfigure}
	\begin{subfigure}{.48\textwidth}
		\centering
		\includegraphics[height=5.5cm]{./Resources/servo/ciclo_30.jpg}
		\caption{Limite de operação inferior}
		\label{excursao_servo:2}
	\end{subfigure}
	\begin{subfigure}{.48\textwidth}
		\centering
		\includegraphics[height=5.5cm]{./Resources/servo/ciclo_110.jpg}
		\caption{Limite de operação superior}
		\label{excursao_servo:3}
	\end{subfigure}
	\begin{subfigure}{.48\textwidth}
		\centering
		\includegraphics[height=5.5cm]{./Resources/servo/ciclo_114.jpg}
		\caption{Limite físico superior}
		\label{excursao_servo:4}
	\end{subfigure}
	\captionsetup{justification=centering}
	\caption[Limites de excursão do servo-motor]{Limites de excursão do servo-motor}
	\label{excursao_servo}
\end{figure}

A partir do ensaio realizado, pôde ser observado que quando funcionando muito próximo dos limites de excursão, o motor gera vibração mecânica e calor excessivos. Como a excursão máxima, em graus, é maior do que 180\si{\degree}, a faixa segura de operação foi definina para $30 < ciclo < 110$, tendo em vista que essa faixa tem uma excursão aproximada de 180\si{\degree} e está distante dos valores mínimo e máximo de excursão.

Voltando ao Proteus, ao simular o circuito, foi adicionado um osciloscópio ao pino de controle do servo motor, possibilitando a predição do tempo em alta do sinal. Três simulações para valores notáveis de "ciclo", i.e. incremento mínimo de $\Delta$t, foram feitas: para ciclo=1, determinando o offset da temporização, pois há atrasos de chamada de rotina de configuração dos temporizadores; ciclo=25, determinando o valor mínimo de operação e; ciclo=114, determinando o valor máximo de operação. Os resultados são mostrados na Figura \ref{sim_proteus}, onde é observado no osciloscópio o sinal para ciclo=1 e diversas marcações de temporização para outros valores de ciclo.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{./Resources/servo/limite_menor_pulso.png}
	\captionsetup{justification=centering}
	\caption[Simulação para obtenção do valor mínimo de incremento $\Delta$t]{Simulação para obtenção do valor mínimo de incremento $\Delta$t}
	\label{sim_proteus}
\end{figure}

Diversas outras amostras de $\Delta$t foram registradas e seus valores interpolados de maneira a observar a linearidade tmin com a qual $\Delta$t é incrementado. O gráfico da Figura \ref{graph_servo_incr} apresenta os resultados.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/servo/grafico_linear.png}
	\captionsetup{justification=centering}
	\caption[Gráfico de $\Delta$t em função de \textit{ciclo}]{Gráfico de $\Delta$t em função de \textit{ciclo}}
	\label{graph_servo_incr}
\end{figure}

A partir do ensaio e da simulação aqui descritos, foram obtidos os limites de operação do servomotor TowerPro MG995 e a fórmula de $\Delta$t, demonstrada na equação \ref{eq_delta} em função do valor do seu incremento mínimo (ciclo). A tabela \ref{limites_servo} resume os limites de temporização do servo-motor MG995.

\begin{align}
	\label{eq_delta}
	\Delta t = (ciclo-1) \cdot t_min + offset \\
	t_min = 20\si{\micro}s \nonumber \\
	offset = 35\si{\micro}s \nonumber
\end{align}

\begin{center}
	\begin{table}[H]
		\centering
		\captionsetup{justification=centering}
		\caption[Limites de temporização do servo-motor TowerPro MG995]{Limites de temporização do servo-motor TowerPro MG995}
		\label{limites_servo}
		\begin{tabular}{ | M{10cm} | M{5cm} |}
			\hline
			\textbf{Limite} & \textbf{Valor (ms)} \\ \hline
			período mínimo & 10 \\ \hline
			excursão mínima & 0,515 \\ \hline
			excursão mínima ideal & 0,615 \\ \hline
			excursão máxima & 2,295 \\ \hline
			excursão máxima ideal & 2,215 \\ \hline
		\end{tabular}
	\end{table}
\end{center}

É importante que os limites de temporização sejam respeitados, uma vez que o motor, cuja excursão máxima é limitada mecânicamente, tenta compensá-la requisitando cada vez mais corrente da fonte, até queimar. Geralmente quando os limites são excedidos ou chegam próximos do máximo, o motor começa a vibrar e aquecer, indicando ao projetista atento que há algo errado.

\section{Código-fonte}
\input{./SourceCodes/at_servo_code.tex}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Cálculo de OG e IBU de uma receita de cerveja}
\label{Apêndice C}

Neste apêndice é apresentado o cálculo da gravidade original (OG) e do amargor (IBU) de uma receita de cerveja, baseado em \cite{palmer}. Em primeiro lugar, é importante salientar que o cálculo da OG e do IBU dependem fortemente de dados do equipamento de produção de cerveja e/ou de constantes levantadas empiricamente, o que significa que este roteiro deve ser visto como um guia e, portanto, na necessidade de obter dados exatos, medições feitas por laboratórios especializados são necessárias.

Primeiramente é preciso calcular as unidades de ácidos alfa, que é um meio para quantificar a contribuição de amargor independentemente do tipo de lúpulo. Para isto, o peso em onças é multiplicado pela porcentagem de ácidos alfa, medida em laboratório e fornecida pelo fabricante. A fórmula para cálculo de AAU é apresentada na equação \ref{eq_aau}. Outra aplicação interessante é quando uma variaedade específica de lúpulo tem sua porcentagem de ácidos alfa diferente em anos diferentes: neste caso, sabendo a AAU da receita original, é fácil recalcular a massa necessária para adequar a receita às novas especificações.

\begin{equation}
	\label{eq_aau}
	AAU = w\cdot aa
\end{equation}

Outro parâmetro de padronização de uma cerveja é a gravidade original, que nada mais é do que a densidade do mosto após o cozimento dos grãos. Ela é baseada nos pontos de contribuição ($pts$) de cada malte, ou seja, uma transformação numérica da gravidade original do malte, que quantifica a contribuição de açúcares do malte em questão para o mosto e indicada em $g/cm^3$. O valor da gravidade original do malte é fornecido pelo fabricante geralmente em pontos, mas a equação \ref{eq_pontos} expressa o cálculo a partir do valor da densidade. Com isso é possível calcular a gravidade original do mosto, conforme descrito na equação \ref{eq_ograv}, na qual $n$ é o número de maltes empregados na receita, $\eta$ é a eficiência do equipamento, ou capacidade de extração de açúcares fermentáveis dos grãos para o mosto e V é o volume final de cerveja. Observe-se que o volume é expresso em galões e a massa em onças.

\begin{equation}
	\label{eq_pontos}
	pts_{malte} = (1-OG_{malte})\cdot 1000
\end{equation}

%How to Brew pg ~164 e pg ~59
\begin{equation}
	\label{eq_ograv}
	OG = \left\{\left[\displaystyle\sum_{n} (pts_n\cdot w_n)\right]\cdot \frac{\eta}{1000\cdot V}\right\} + 1
\end{equation}

A utilização é um dos fatores mais críticos para o cálcula adequado da quantidade de IBU da cerveja. Ela é uma função da OG e do tempo de fervura. Uma vez que seu valor é fortemente dependente do vigor da fervura, da química do mosto e de outros parâmetros difíceis de quantificar, valores empíricos de constantes são empregados como um ponto de estimação de IBU --- embora com o tempo o operador do equipamento deva fazer um ajuste fino destas constantes para aumentar a precisão do cálculo. O cálculo da utilização $u$ é apresentado no conjunto de equações \ref{eq_utilizacao}.

\begin{subequations}
	\label{eq_utilizacao}
	\begin{align}
		&u = f(OG)\cdot f(t), \quad onde:\\
		&f(OG) =  1,65\cdot 0,000125^{(OG-1)}\\
		&f(t) = \frac{1-\epsilon^{-0,04t}}{4,15}
	\end{align}
\end{subequations}

Finalmente, é possível calcular a quantidade de amargor da cerveja usando a fórmula \ref{eq_ibu}, na qual V é o volume final da produção expresso em galões e 74,89 é o fator de conversão de onças por galão para miligramas por litro, unidade do IBU.

\begin{equation}
	\label{eq_ibu}
	IBU = \frac{AAU\cdot u\cdot 74,89}{V}
\end{equation}

\section{Estimação do IBU para uma receita de 20l}

Para saber se 400g de lúpulos são suficientes para uma receita de 20 litros, foi feito um cálculo hipotético considerando situações extremas: densidade original alta ($1,120g/cm^3$), tempo de fervura alto (120min), lúpulo nobre (baixo teor de ácidos alfa = 5\%):

\begin{subequations}
	\label{eq_utilizacao}
	\begin{align}
		&AAU = (400\cdot 0,035274)\cdot 5,0 = 70,55 \nonumber\\
		&f(OG) =  1,65\cdot 0,000125^{(1,12-1,00)} = 0,56 \nonumber\\
		&f(t) = \frac{1-\epsilon^{-0,04\cdot 120}}{4,15} = 0,24 \nonumber\\
		&u = 0,56\cdot 0,24 = 0,135 \nonumber\\
		&IBU = \frac{70,55\cdot 0,135\cdot 74,89}{20\cdot 0,264} = 135 mg/l \nonumber
	\end{align}
\end{subequations}

Considerando o guia do BJCP (Beer Judge Certification Program), que é adotado por profissionais ao redor de todo o mundo para participarem de competições de cervejas como juízes, os dois estilos de cerveja com maior amargor são \textit{Imperial India Pale Ale} e \textit{American Barley Wine}, ambos com limite superior de 120 IBU \cite{styles_ibu} e o livro \textit{How to Brew} que descreve somente um estilo com mais de 120 IBU --- justamente o \textit{American Barley Wine} --- é razoável assumir que raramente será necessário operar a estrutura de adição de lúpulos em sua capacidade máxima.

\chapter{Análise do tempo de leitura do sensor DS18B20 em Python}
\label{analise_tread_temp}

Uma vez que o sistema operacional Linux não é de tempo real, é sensato concluir que um laço de repetição que gera um registro não terá um tempo de amostragem fixo, mas sim um valor médio, e este foi o caso do presente projeto. A confirmação se deu a partir de um estudo do tempo de amostragem de temperatura do DS18B20, sob as seguintes condições: o \textit{log} de temperaturas foi executado independente do script que gera os gráficos em Python. O servidor em Node.js estava sendo executado porém inativo, o que significa que nenhum tipo de requisição foi feita por meio da interface web.

Foram realizadas amostragens com a prioridade de processo do Linux definida como padrão (nice=0) e máxima (nice=-20). O script Python foi modificado para que o número de pontos de amostragem fosse definido como 500 pontos, sendo os resultados estatísticos da amostragem descritos na tabela \ref{amostragem_py} e no histograma de distribuição dos tempos de amostragem, exposto na figura \ref{histograma_py}.

\begin{table}[H]
	\centering
	\captionsetup{justification=centering}
	\caption[Estatísticas referentes ao tempo de amostragem de temperatura na BBB, para 500 pontos em Python]{Estatísticas referentes ao tempo de amostragem de temperatura na BBB, para 500 pontos em Python}
	\label{amostragem_py}
	\begin{tabular}{ | M{5cm} | M{2.5cm} | M{2.5cm} |}
		\hline
		 & \textbf{Sem prioridade (s)} & \textbf{Com prioridade (s)} \\ \hline
		Média & 1,7798 & 1,7785\\ \hline
		Desvio padrão & 2,5481e-3 & 2,2893e-3\\ \hline
		Máximo & 1,7891 & 1,7907\\ \hline
		Mínimo & 1,7773 & 1,7754\\ \hline
		Mediana & 1,7793 & 1,7774\\ \hline
		Moda/ocorrências & 1,7773 / 6 & 1,7773 / 8\\ \hline
	\end{tabular}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.47]{./Resources/histograma1.png}
	\captionsetup{justification=centering}
	\caption[Histograma de distribuição do tempo de amostragem de temperatura]{Histograma de distribuição do tempo de amostragem de temperatura}
	\label{histograma_py}
\end{figure}

Observando e comparando as estatísticas, é possível observar uma redução de 10\% na variância, indicando que a maioria das medidas está mais próxima do valor médio --- que também ficou um pouco mais próximo do valor esperado --- no caso com prioridade. Este fato já era esperado, pois com a prioridade, maior tempo do processador é alocado ao processo e, por conseguinte, menor é a probabilidade de que ele seja interrompido. A amplitude dos valores foi de 11,8ms sem prioridade contra 15,3ms com prioridade. No código, embora tenha sido introduzido um atraso de somente 1s, o tempo médio entre amostras de cerca de 1,77s ocorreu pois cada leitura do sensor de temperatura leva 750ms, de acordo com a documentação do \textit{driver} do Kernel.

Observa-se que, pela quantidade de ocorrências da moda, ela representou 1,6\% do total de medidas no melhor caso. Assim sendo, foi decidido recorrer ao histograma, que apresenta o local de uma faixa de valores. A maior concentração de dados no experimento com prioridade de processo, reafirma seu comportamento mais desejável. Nos dois casos, a maior concentração de valores está próxima da moda, rebatendo a hipótese de que ele é um valor de pouca significância se observado que representa somente 1,6\% do total. Por fim, observando o histograma, não foi possível obter uma distribuição de probabilidade conhecida.

Tendo em vista o tempo de amostragem, levado em consideração o tempo de leitura do sensor pelo driver do Kernel, decidiu-se por usar um tempo de amostragem de 0,75s (módulo) + 0,25s (script Python) - 0,0298s (tempo médio de amostragem - tempo esperado de amostragem) = 0,2202s.

\chapter{Diagrama esquemático do circuito de acionamentos de potência}
\label{esquematico_acionamentos}

\newpage

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/proteus/potenciaFolha1_menor.png}
	%\captionsetup{justification=centering}
	%\caption[Módulo do circuito de acionamentos de potência]{Módulo do circuito de acionamentos de potência}
	%\label{pot_one_module}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.50]{./Resources/proteus/potenciaFolha2_menor.png}
	%\captionsetup{justification=centering}
	%\caption[Módulo do circuito de acionamentos de potência]{Módulo do circuito de acionamentos de potência}
	%\label{pot_one_module}
\end{figure}
