\chapter{Conclusões}
\label{Conclusao}

Este capítulo é dedicado às conclusões levantadas a partir dos resultados obtidos para este trabalho de conclusão de curso. No intuito de facilitar a organização destas, o capítulo está dividido em seções nas quais se discorrem tópicos específicos do projeto, buscando seguir a ordem do capítulo de resultados.

\section{Sistema de controle de versão}

Com relação ao sistema de controle de versão \textit{Git} e o serviço online \textit{GitHub}, foi observado o poder que estas ferramentas proporcionam à documentação e manutenção de um projeto que envolve \textit{software}. O simples fato de documentar cada mudança feita ao código-fonte de maneira simples, no nível de detalhamento que o usuário considerar adequado, já justificou o seu uso: este nível de documentação e sua facilidade são um dos pontos essenciais para a facilidade de documentação de código, pois o desenvolvedor sabe o que foi modificado e quando gastando um mínimo esforço.

A possibilidade de desenvolver esta monografia empregando o \textit{GitHub} como um meio de \textit{backup} e de ter os arquivos necessários disponíveis em qualquer lugar também foi um dos pontos fortes observados que justificou o uso da ferramenta --- além de que os registros incrementais ajudaram a recuperar o raciocínio em períodos nos quais a escrita foi deixada em segundo plano em função do desenvolvimento do projeto.

Embora tenha sido lógico o resultado estatístico do \textit{punchcard}, apresentado na seção \ref{git_res} --- em função de tarefas de maior prioridade executadas durante os dias úteis da semana, foi observado que o desenvolvimento do TCC se deu nos horários livres --- é possível extrapolar o uso desta ferramenta estatística no monitoramento de uma equipe de desenvolvimento de software, que não precisa necessariamente trabalhar em um mesmo local físico.

Por fim, com relação ao \textit{Git}, durante alguns momentos do projeto, foi constatado que apesar de a ferramenta ser excelente para o desenvolvimento de \textit{software}, em última instância ela reflete a disciplina e o hábito do programador no uso desta. Isto foi notado em momentos nos quais mudanças simples, mas importantes para o código-fonte, eram ignoradas no sentido de atualizá-las no \textit{Git}. Outra questão importante com relação ao uso que se faz desta ferramenta é que, ao trabalhar em uma equipe, provavelmente seja melhor combinar com os colaboradores qual o nível de detalhamento desejado para a documentação e quais as técnicas de uso, e.g. criar uma ramificação para consertar um determinado bug ou somente para implementar uma nova funcionalidade, dentre outras possibilidades.

\section{Geração de gráficos e registro de temperatura em Python}

É importante notar que as duas aplicações escritas em Python para este projeto, foram desenvolvidas em uma fase inicial, ou seja, ao longo do primeiro mês e meio deste. Isto significa que, naquele momento, o desenvolvedor não possuía conhecimentos práticos de Linux embarcado e nem mesmo de linguagens de programação de alto nível, com excessão de MATLAB. Isto foi traduzido em dois pontos que foram constatados somente muito tempo depois da escrita dos códigos Python: a curva de aprendizado de todo um sistema novo custou uma parcela significativa de tempo do projeto e; o fato de as tarefas necessárias para cumprir o projeto estarem mal definidas naquele momento inicial, levaram o desenvolvedor a usar mais tempo do que seria razoável destinar a esta tarefa.

A análise do tempo de leitura do sensor DS18B20, descrita no apêndice \ref{analise_tread_temp} comprova o resultado que se espera sabendo que o Linux não é um sistema operacional de tempo-real: o tempo de amostragem não é constante. Este é um fato já conhecido e, portanto, a análise conduzida não significa necessariamente uma contribuição inovadora. Por outro lado, esta análise levou o desenvolvedor à ideia de que talvez seja possível criar dentro do próprio script uma maneira de ajustar o tempo de amostragem a partir de valores anteriores de tal modo que o tempo médio seja o desejado, o que requer um estudo de caso e análise de aplicação: vislumbrando o fato de que o DS18B20 possui tempo mínimo de amostragem de 750ms e que a resposta de um sistema térmico é muito lenta se comparada com um sistema eletrônico, talvez fosse interessante estudar a possibilidade e os efeitos da implementação de um controlador PID sob as condições propostas.

Quanto ao gráfico de temperatura, seu uso ficou restrito ao início do projeto e foi relegado ao segundo plano depois da implementação do gráfico dinâmico usando D3.js e Rickshaw. O conhecimento adquirido a partir da necessidade de gerar este gráfico mostrou que a linguagem de programação Python é aliada de pesquisadores, com as bibliotecas NumPy e SciPy, dentre outras, e pode ser uma alternativa de baixo custo a soluções proprietárias como o MATLAB; por outro lado, a curva de aprendizado e, possivelmente a facilidade de consulta a documentação sejam pontos nos quais as soluções proprietárias se sobressaem. Também foi surpreendente o fato de a BBB plotar em 2,1 segundos um gráfico com 7200 pontos --- em parte a surpresa se deu pelo fato de o desenvolvedor não conhecer as limitações da plataforma que estava usando, quando foi desenvolvido o script que plota o gráfico.

O registro de temperatura de 38 dias ininterruptos 27 caracteres codificados em UTF-8 mostra que a linguagem Python, na plataforma BBB, suportou criar e lidar com um arquivo de registros CSV de 3.283.200 entradas, o que representa um arquivo de 95,2MB, sabendo-se que cada entrada ocupou 29 caracteres no arquivo. Esta reflexão também levou à consideração de que deveria ter sido implementado um banco de dados, ao menos para testes.

Por fim, estes códigos ficaram legados no projeto, porém poderiam facilmente ser substituídos por módulos em Node.js, o que padrozinaria a aplicação e a tornaria mais coerente, do ponto de vista que não seria necessário executar um comando do shell a partir do Node.js para executar o script Python. Além disto, o comportamento assíncrono do Node.js possibilitaria a leitura do DS18B20, que demora 750ms, em paralelo com outras atividades nativamente, o que é um benefício não implementado no script Python.

\section{Aplicação \textit{server-side} em Node.js}

Node.js foi a linguagem de programação (interpretador da lingaugem Javascript) adotada \textit{de facto} como a linguagem de servidor para o presente projeto. Seu uso foi motivado pela existência da biblioteca de acesso a hardware \textit{Octalbonescript} e da IDE Cloud9, e se tornou a escolha do desenvolvedor, uma vez que foi considerada de fácil aprendizado, reduziu a complexidade do projeto uma vez que reuniu todas as particularidades deste em torno de si --- desde a leitura dos sensores de temperatura até a comunicação com o cliente. Cabe ressaltar que, embora a atualização dos programas instalados na BBB não tenha sido parte do escopo deste projeto, neste momento o interpretador Node.js está na versão 6.0, enquanto a empregada na BBB é a versão 0.10 --- o que pode ter impactado negativamente na performance do sistema em algum momento.

A partir do estudo de acesso a GPIO, cujos resultados estão documentados na seção \ref{nodectrl_res}, foi observado que o tempo mínimo de chaveamento foi limitado por algum fator que não a carga da CPU, o que reforçou a hipótese de a versão antiga do Node estar limitando o seu desempenho --- testes mais aprofundados devem ser realizados para comprovar ou refutar esta hipótese.

O erro entre tempo de chaveamento esperado e medido foi alto a ponto de inviabilizar o uso desta tecnologia em aplicações que necessitam de precisão de temporização, porém não foi tão alto que não possa ser considerado seu uso para algum caso mais trivial, como algum controle de potência de um elemento secundário de um projeto no qual os recursos de hardware já estiverem comprometidos. Também não foi estudada a implementação da biblioteca \textit{Octalbonescript} --- há mais de uma maneira de acessar GPIO em Node.js (por meio do \textit{/sys/class} ou usando um \textit{add-on} escrito em C que implemente acesso direto à memória) e a implementação apresentada por esta biblioteca pode não ser a mais rápida. Por outro lado, o PWM implementado em hardware se mostrou estável a tal ponto que a senóide da rede apresentou estabilidade em frequência menor, o que levou à criação do detector de passagem por zero para sincronismo.

O servidor web implementado por meio do \textit{framework} Express se mostrou estável e ocupou poucos recursos da BBB, além de passar por um teste de estresse que comprovou sua virtude para processamento de I/O intensivo. Embora seja notável que nenhum equipamento de produção de cerveja deve ter 200 operadores conectados a ele, por questões logísticas e de segurança, o teste de estresse mostrou a possibilidade de implementar um servidor em Node para fazer comunicação com diversas cervejarias de consumidores finais e promover não somente serviços de \textit{backup} para os usuários do produto mas também a possibilidade de desenvolver aplicações de internet das coisas, no sentido de reunir grandes conjuntos de dados e aplicar algoritmos de aprendizado de máquina para atuar na performance dos equipamentos, detectar falhas antes mesmo que elas aconnteçam, levantar padrões de preferências de consumidor para elaborar receitas de cerveja mais saborosas, dentre outras inúmeras possibilidades.

No âmbito de internet das coisas, a questão da segurança é um tópico fortemente discutido e trabalhado, mas que não foi testado neste trabalho. Seria preciso verificar quais os recursos de proteção disponíveis no \textit{framework} Express ou mesmo em outros módulos.

Com relação aos registros implementados em Node.js, exceptuando-se a questão de executar o script Python que já foi comentada, observou-se que o registro do processo de brassagem é extremamente ineficiente: foi implementado um campo de avisos que nunca é acessado pelo código-fonte; a variável para mensagem de descrição que é basicamente a mesma coisa que o código e que poderia ser omitida sem prejuízo para o registro da brassagem; o registro da variável global \textit{readyForNextStep} é completamente desnecessário, uma vez que esta é modificada tão rapidamente não aplicação que suas variações nunca são refletidas no registro; o uso de 36 variáveis para \textit{timestamps}, enquanto somente um campo relacionado a uma amplitude maior de códigos de processo seria suficiente para economizar não somente recursos do eMMC como também recursos de memória RAM do sistema, além de simplificar o processo de verificação visual do arquivo de registros e; o registro da variável \textit{okToStart} que nunca varia.

Além disto, cada entrada de registro é escrita no arquivo de \textit{log} codificada no formato JSON, que é basicamente uma maneira de documentar um objeto Javascript. Não somente seria mais econômico em termos de recursos de armazenamento como de processamento de strings utilizar nomes mais curtos para as variáveis como também seria muito mais interessante usar um banco de dados não relacional, como por exemplo o MongoDB, discorrido no embasamento teórico e que é o casamento perfeito para esta aplicação. Estas conclusões acerca do registro podem não fazer grande diferença no âmbito de um único equipamento mas, novamente extrapolando para a ideia de um serviço de IoT, percebe-se imediatamente os ganhos de escala implícitos nas otimizações apontadas. 

Ainda, no módulo de registros, está implementada a função que verifica se uma receita pode ser iniciada ou não. Talves fosse interessante fazer esta verificação no momento em que a receita é salva, porém com o recurso de salvamento automático, este pode não ser o melhor caminho. Também poderia ser interessante modificar o paradigma de chamadas à função de \textit{log} de tal maneira que fosse evitado o processo de iniciar e parar o timer do laço \textit{setInterval} que a invoca no intuito de modificar os seus parâmetros de chamada.

A simulação do controle do processo de brassagem se mostrou essencial para garantir a implementação coerente da automação do sistema. Ainda assim, não somente a aplicação deveria ter sido arquitetada desde o começo favorecendo o processo de \textit}debug} como ferramentas auxiliares de prevenção a erros e testes deveriam ter sido adotadas. Uma ferramenta simples de prevenção a erros e boas práticas é o \textit{jshint} --- uma ferramenta de análise estática de código inicialmente desenvolvida por Douglas Crockford, o criador e disseminador da codificação JSON. As mensagens de \textit{debug} impressas no terminal também poderiam ter sido separadas de maneira mais eficiente e não somente por módulos.

Quanto aos recursos computacionais demandados pelo processo de produção de cerveja, quando em modo automático, foi importante notar que não houve sobrecarga do sistema, uma vez que o usuário não é impedido de acessar nenhuma função da GUI neste período. Foi interessante notar que, após a fervura do mosto, o consumo de recursos de processamento caiu pela metade e este fator foi atribuído a princípio à parada de execução do script Python no final da função \textit{theBoil}. Cabe ressaltar que esta foi somente uma hipótese e precisa ser testada antes de ser tomada como verdade absoluta. No quesito de recursos de rede, o tráfego foi baixo mesmo com o \textit{overhead} gerado pelo envio de dados desnecessários do servidor para o cliente --- os mesmos dados discutidos com relação ao arquivo de registro da brassagem.

\section{Interface de usuário}

A interface de usuário foi projetada para apresentação em um display de resolução específico, muito embora testes em outras resoluções tenham mostrado que ela se ajustou sem perda de funcionalidades e, em certos casos, com poucas distorções de design. Este tópico é extremamente relevante quando se fala em controle via internet, já que a popularização dos \textit{smartphones} promoveu o acesso da população à internet por meio de displays dos mais variados tamanhos. Certamente seria de grande utilidade o desenvolvimento de aplicativos para celulares.

No que diz respeito à barra de navegação, esta não foi inicialmente planejada, porém promoveu a navegabilidade da GUI, que antes era cansativa em função de uma estrutura com diversos botões de voltar e um menu que concentrava todas funcionalidades. Neste ponto, a barra de navegação foi um dos itens de sucesso da parte do projeto voltada ao usuário. A página de configurações trouxe conhecimento aplicado acerca do uso do protocolo NTP, porém a sensação que ela transparece é de que faltam opções de configuração e que, talvez esta página em específico nem devesse existir e a função de ajuste de hora deveria ser realocada.

A página de estatísticas apresentou uma implementação interessante de gráfico dinâmico e configurável em diversos aspectos, o que trouxe à reflexão: o usuário final realmente precisa de todos estes recursos de configuração? Ele quer estes recursos à sua disposição? Ele se sente seguro diante de uma gama de recursos que não irão efetivamente melhorar sua experiência com o produto? Mesmo que a resposta para todas estas questões seja sim, ainda assim ficou claro, após a observação dos resultados, que ao menos o filtro de médias móveis deveria ser omitido, pois além de não trazer vantagem, pode distorcer o gráfico de temperatura.

Quanto à interface de brassagem, sua implementação ficou limpa e funcional, ótima para controle tanto por meio da interface \textit{desktop} à qual ela foi projetada quanto por meio de um dispositivo móvel. Seu único problema --- a questão do \textit{glitch} --- foi solucionado ao mesmo tempo em que foi detectado. Obviamente a solução impacta em maior consumo de recursos computacionais da BBB, exigindo um novo estudo, porém é inegável sua eficácia.

A exemplo dos \textit{glitches} da interface de brassagem, a interface de receitas também apresentou alguns problemas, porém a partir do momento que estes foram notados, sua solução é simples do ponto de vista do desenvolvedor desta GUI. A interface cumpriu seu propósito de maneira fluída e despreocupante do ponto de vista de usuário, sem impactar significativamente no consumo de recursos da máquina do cliente.

\section{Circuitos de interface entre a BBB e sensores/atuadores}

Com relação aos circuitos projetados, o que se observou foi que nos testes de bancada estes corresponderam ao comportamento obtido por meio de simulações e, portanto, suas funções foram atingidas com êxito. Em função do tempo impeditivo, não foi possível realizar uma implementação em PCB, porém este é um passo essencial no longo prazo, já que não é possível produzir um produto usando uma matriz de contatos.

Foi interessante constatar que a frequência da rede é variável em torno 60Hz e também que o SSR só pode ser disparado quando a tensão passa por zero: ambos os fatores combinados foram os responsáveis pelo projeto do detector de passagem por zero, que permitiria o controle do número de semiciclos de senóide nos quais os resistores de potência estariam ativos e isto, por sua vez, poderia permitir um controle mais preciso da potência destes do que uma janela de tempo por si só. Mais uma vez, estas hipóteses só podem ser confirmadas com uma nova implementação e testes de comparação de janela de tempo versus controle do número de ciclos. O comportamento da alimentação do servo-motor também foi interessante do ponto de vista de conhecimento, mas não impactou diretamente no projeto proposto --- a propósito, seu funcionamento foi o único resultado relacionado à estrutura de adição de lúpulos, que não foi construída.

Quanto ao detector de \textit{zero-crossing}, a única observação prática é o fato de que a saída do circuito começa a indicar passagem por zero meio período de duração do pulso antes da passagem efetiva por zero, portanto em usos posteriores este comportamento deve ser levado em conta.

\section{Estrutura mecânica}

A implementação da estrutura mecânica foi o ponto ao qual mais foram despendidos recursos, sejam eles financeiros ou de tempo. Não somente a complexidade deste projeto, mas também o pouco conhecimento de mecânica do projetista foram fatores que influenciaram neste alto custo. Por falta de experiência o equipamento projetado se mostrou desajeitado para manutenção e limpeza, portanto cabe ao usuário do sistema ser disciplinado ao utilizá-lo e realizar a limpeza o quanto antes possível, mesmo que seja uma tarefa complexa. Cabe notar que, na idealização do projeto, este seria equipado com um sistema CIP completo, o que não foi possível devido a custo de implementação e complexidade elevada que seria adicionada à proposta do projeto.

O funcionamento da simulação de produção comprovou a capacidade do sistema de produzir uma receita de cerveja, porém a produção de uma receita em si requer que mais testes sejam realizados, para fazer ajustes finos do equipamento, das temporizações, adicionar os detectores de transbordamento das panelas, dentre outros tópicos que surgirem ao longo dos futuros testes. Após os testes preliminares descritos no capítulo de resultados, também é preciso modificar alguns aspectos da aplicação do servidor, de modo a impedir o usuário de ligar as válvulas e bombas em configurações que possam danificar ou sobrecarregar o sistema.

\section{Considerações gerais}

Por fim, conclui-se que os pré-requisitos para o funcionamento do sistema automatizado de produção de cerveja com controle e monitoramento remoto foram implementados. Ainda assim, os resultados das implementações mostraram diversos pontos de melhoria até que um produto seja viável. Além disto, notou-se que a integração entre os diversos aspectos do projeto --- parte mecânica, GUI, acionamentos de potência e algoritmo de automação --- foi descomplicada e não causou transtornos. Atribui-se a estas observações o detalhamento com que cada ponto foi desenvolvido separadamente.

\section{Trabalhos futuros}

Como trabalhos futuros, ficam todas as correções expostas nas outras seções deste capítulo em primeiro lugar. Além disto, é interessante implementar um sistema de controle de temperatura por meio de um controlador PID, possivelmente mais adequado do que o método empregado neste trabalho --- para tal, pode-se fazer o uso do subsistema PRU presente na BBB e cujo apêndice \ref{apendice_pru} apresenta um estudo teórico.

Outros aspectos do trabalho que devem ser melhorados em futuras ocasiões são o retrabalho do projeto do sistema mecânico com foco em ergonomia, simplificação da estrutura e certificação para que a produção de cerveja possa ser comercializada; um projeto mais detalhado do cabeamento que faz a interface entre o circuito de acionamentos de potência e os elementos de potência e; um bastidor para alojar o sistema embarcado de maneira protegida contra derramamento de líquidos. Também entra para a lista de trabalhos futuros a construção e teste da estrutura de adição de lúpulos e o projeto de uma estrutura de adição de grãos.











