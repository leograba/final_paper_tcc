\chapter{Conclusões}
\label{Conclusao}

Este capítulo é dedicado às conclusões levantadas a partir dos resultados obtidos para este trabalho de conclusão de curso. No intuito de facilitar a organização destas, o capítulo está dividido em seções nas quais se discorrem tópicos específicos do projeto, buscando seguir a ordem do capítulo de resultados.

\section{Sistema de controle de versão}

Com relação ao sistema de controle de versão \textit{Git} e o serviço online \textit{GitHub}, foi observado o poder que estas ferramentas proporcionam à documentação e manutenção de um projeto que envolve \textit{software}. O simples fato de documentar cada mudança feita ao código-fonte de maneira simples, no nível de detalhamento que o usuário considerar adequado, já justificou o seu uso: este nível de documentação e sua facilidade são um dos pontos essenciais para a facilidade de documentação de código, pois o desenvolvedor sabe o que foi modificado e quando gastando um mínimo esforço.

A possibilidade de desenvolver esta monografia empregando o \textit{GitHub} como um meio de \textit{backup} e de ter os arquivos necessários disponíveis em qualquer lugar também foi um dos pontos fortes observados que justificou o uso da ferramenta --- além de que os registros incrementais ajudaram a recuperar o raciocínio em períodos nos quais a escrita foi deixada em segundo plano em função do desenvolvimento do projeto.

Embora tenha sido lógico o resultado estatístico do \textit{punchcard}, apresentado na seção \ref{git_res} --- em função de tarefas de maior prioridade executadas durante os dias úteis da semana, foi observado que o desenvolvimento do TCC se deu nos horários livres --- é possível extrapolar o uso desta ferramenta estatística no monitoramento de uma equipe de desenvolvimento de software, que não precisa necessariamente trabalhar em um mesmo local físico.

Por fim, com relação ao \textit{Git}, durante alguns momentos do projeto, foi constatado que apesar de a ferramenta ser excelente para o desenvolvimento de \textit{software}, em última instância ela reflete a disciplina e o hábito do programador no uso desta. Isto foi notado em momentos nos quais mudanças simples, mas importantes para o código-fonte, eram ignoradas no sentido de atualizá-las no \textit{Git}. Outra questão importante com relação ao uso que se faz desta ferramenta é que, ao trabalhar em uma equipe, provavelmente seja melhor combinar com os colaboradores qual o nível de detalhamento desejado para a documentação e quais as técnicas de uso, e.g. criar uma ramificação para consertar um determinado bug ou somente para implementar uma nova funcionalidade, dentre outras possibilidades.

\section{Geração de gráficos e registro de temperatura em Python}

É importante notar que as duas aplicações escritas em Python para este projeto, foram desenvolvidas em uma fase inicial, ou seja, ao longo do primeiro mês e meio deste. Isto significa que, naquele momento, o desenvolvedor não possuía conhecimentos práticos de Linux embarcado e nem mesmo de linguagens de programação de alto nível, com excessão de MATLAB. Isto foi traduzido em dois pontos que foram constatados somente muito tempo depois da escrita dos códigos Python: a curva de aprendizado de todo um sistema novo custou uma parcela significativa de tempo do projeto e; o fato de as tarefas necessárias para cumprir o projeto estarem mal definidas naquele momento inicial, levaram o desenvolvedor a usar mais tempo do que seria razoável destinar a esta tarefa.

A análise do tempo de leitura do sensor DS18B20, descrita no apêndice \ref{analise_tread_temp} comprova o resultado que se espera sabendo que o Linux não é um sistema operacional de tempo-real: o tempo de amostragem não é constante. Este é um fato já conhecido e, portanto, a análise conduzida não significa necessariamente uma contribuição inovadora. Por outro lado, esta análise levou o desenvolvedor à ideia de que talvez seja possível criar dentro do próprio script uma maneira de ajustar o tempo de amostragem a partir de valores anteriores de tal modo que o tempo médio seja o desejado, o que requer um estudo de caso e análise de aplicação: vislumbrando o fato de que o DS18B20 possui tempo mínimo de amostragem de 750ms e que a resposta de um sistema térmico é muito lenta se comparada com um sistema eletrônico, talvez fosse interessante estudar a possibilidade e os efeitos da implementação de um controlador PID sob as condições propostas.

Quanto ao gráfico de temperatura, seu uso ficou restrito ao início do projeto e foi relegado ao segundo plano depois da implementação do gráfico dinâmico usando D3.js e Rickshaw. O conhecimento adquirido a partir da necessidade de gerar este gráfico mostrou que a linguagem de programação Python é aliada de pesquisadores, com as bibliotecas NumPy e SciPy, dentre outras, e pode ser uma alternativa de baixo custo a soluções proprietárias como o MATLAB; por outro lado, a curva de aprendizado e, possivelmente a facilidade de consulta a documentação sejam pontos nos quais as soluções proprietárias se sobressaem. Também foi surpreendente o fato de a BBB plotar em 2,1 segundos um gráfico com 7200 pontos --- em parte a surpresa se deu pelo fato de o desenvolvedor não conhecer as limitações da plataforma que estava usando, quando foi desenvolvido o script que plota o gráfico.

O registro de temperatura de 38 dias ininterruptos 27 caracteres codificados em UTF-8 mostra que a linguagem Python, na plataforma BBB, suportou criar e lidar com um arquivo de registros CSV de 3.283.200 entradas, o que representa um arquivo de 95,2MB, sabendo-se que cada entrada ocupou 29 caracteres no arquivo. Esta reflexão também levou à consideração de que deveria ter sido implementado um banco de dados, ao menos para testes.

Por fim, estes códigos ficaram legados no projeto, porém poderiam facilmente ser substituídos por módulos em Node.js, o que padrozinaria a aplicação e a tornaria mais coerente, do ponto de vista que não seria necessário executar um comando do shell a partir do Node.js para executar o script Python. Além disto, o comportamento assíncrono do Node.js possibilitaria a leitura do DS18B20, que demora 750ms, em paralelo com outras atividades nativamente, o que é um benefício não implementado no script Python.

\section{Aplicação \textit{server-side} em Node.js}

Node.js foi a linguagem de programação (interpretador da lingaugem Javascript) adotada \textit{de facto} como a linguagem de servidor para o presente projeto. Seu uso foi motivado pela existência da biblioteca de acesso a hardware \textit{Octalbonescript} e da IDE Cloud9, e se tornou a escolha do desenvolvedor, uma vez que foi considerada de fácil aprendizado, reduziu a complexidade do projeto uma vez que reuniu todas as particularidades deste em torno de si --- desde a leitura dos sensores de temperatura até a comunicação com o cliente. Cabe ressaltar que, embora a atualização dos programas instalados na BBB não tenha sido parte do escopo deste projeto, neste momento o interpretador Node.js está na versão 6.0, enquanto a empregada na BBB é a versão 0.10 --- o que pode ter impactado negativamente na performance do sistema em algum momento.

A partir do estudo de acesso a GPIO, cujos resultados estão documentados na seção \ref{nodectrl_res}, foi observado que o tempo mínimo de chaveamento foi limitado por algum fator que não a carga da CPU, o que reforçou a hipótese de a versão antiga do Node estar limitando o seu desempenho --- testes mais aprofundados devem ser realizados para comprovar ou refutar esta hipótese.

O erro entre tempo de chaveamento esperado e medido foi alto a ponto de inviabilizar o uso desta tecnologia em aplicações que necessitam de precisão de temporização, porém não foi tão alto que não possa ser considerado seu uso para algum caso mais trivial, como algum controle de potência de um elemento secundário de um projeto no qual os recursos de hardware já estiverem comprometidos. Também não foi estudada a implementação da biblioteca \textit{Octalbonescript} --- há mais de uma maneira de acessar GPIO em Node.js (por meio do \textit{/sys/class} ou usando um \textit{add-on} escrito em C que implemente acesso direto à memória) e a implementação apresentada por esta biblioteca pode não ser a mais rápida. Por outro lado, o PWM implementado em hardware se mostrou estável a tal ponto que a senóide da rede apresentou estabilidade em frequência menor, o que levou à criação do detector de passagem por zero para sincronismo.

O servidor web implementado por meio do \textit{framework} Express se mostrou estável e ocupou poucos recursos da BBB, além de passar por um teste de estresse que comprovou sua virtude para processamento de I/O intensivo. Embora seja notável que nenhum equipamento de produção de cerveja deve ter 200 operadores conectados a ele, por questões logísticas e de segurança, o teste de estresse mostrou a possibilidade de implementar um servidor em Node para fazer comunicação com diversas cervejarias de consumidores finais e promover não somente serviços de \textit{backup} para os usuários do produto mas também a possibilidade de desenvolver aplicações de internet das coisas, no sentido de reunir grandes conjuntos de dados e aplicar algoritmos de aprendizado de máquina para atuar na performance dos equipamentos, detectar falhas antes mesmo que elas aconnteçam, levantar padrões de preferências de consumidor para elaborar receitas de cerveja mais saborosas, dentre outras inúmeras possibilidades.

No âmbito de internet das coisas, a questão da segurança é um tópico fortemente discutido e trabalhado, mas que não foi testado neste trabalho. Seria preciso verificar quais os recursos de proteção disponíveis no \textit{framework} Express ou mesmo em outros módulos.

Com relação aos registros implementados em Node.js, exceptuando-se a questão de executar o script Python que já foi comentada, observou-se que o registro do processo de brassagem é extremamente ineficiente: foi implementado um campo de avisos que nunca é acessado pelo código-fonte; a variável para mensagem de descrição que é basicamente a mesma coisa que o código e que poderia ser omitida sem prejuízo para o registro da brassagem; o registro da variável global \textit{readyForNextStep} é completamente desnecessário, uma vez que esta é modificada tão rapidamente não aplicação que suas variações nunca são refletidas no registro; o uso de 36 variáveis para \textit{timestamps}, enquanto somente um campo relacionado a uma amplitude maior de códigos de processo seria suficiente para economizar não somente recursos do eMMC como também recursos de memória RAM do sistema, além de simplificar o processo de verificação visual do arquivo de registros e; o registro da variável \textit{okToStart} que nunca varia.

Além disto, cada entrada de registro é escrita no arquivo de \textit{log} codificada no formato JSON, que é basicamente uma maneira de documentar um objeto Javascript. Não somente seria mais econômico em termos de recursos de armazenamento como de processamento de strings utilizar nomes mais curtos para as variáveis como também seria muito mais interessante usar um banco de dados não relacional, como por exemplo o MongoDB, discorrido no embasamento teórico e que é o casamento perfeito para esta aplicação. Estas conclusões acerca do registro podem não fazer grande diferença no âmbito de um único equipamento mas, novamente extrapolando para a ideia de um serviço de IoT, percebe-se imediatamente os ganhos de escala implícitos nas otimizações apontadas. 

Ainda, no módulo de registros, está implementada a função que verifica se uma receita pode ser iniciada ou não. Talves fosse interessante fazer esta verificação no momento em que a receita é salva, porém com o recurso de salvamento automático, este pode não ser o melhor caminho. Também poderia ser interessante modificar o paradigma de chamadas à função de \textit{log} de tal maneira que fosse evitado o processo de iniciar e parar o timer do laço \textit{setInterval} que a invoca no intuito de modificar os seus parâmetros de chamada.

A simulação do controle do processo de brassagem se mostrou essencial para garantir a implementação coerente da automação do sistema. Ainda assim, não somente a aplicação deveria ter sido arquitetada desde o começo favorecendo o processo de \textit}debug} como ferramentas auxiliares de prevenção a erros e testes deveriam ter sido adotadas. Uma ferramenta simples de prevenção a erros e boas práticas é o \textit{jshint} --- uma ferramenta de análise estática de código inicialmente desenvolvida por Douglas Crockford, o criador e disseminador da codificação JSON. As mensagens de \textit{debug} impressas no terminal também poderiam ter sido separadas de maneira mais eficiente e não somente por módulos.

Quanto aos recursos computacionais demandados pelo processo de produção de cerveja, quando em modo automático, foi importante notar que não houve sobrecarga do sistema, uma vez que o usuário não é impedido de acessar nenhuma função da GUI neste período. Foi interessante notar que, após a fervura do mosto, o consumo de recursos de processamento caiu pela metade e este fator foi atribuído a princípio à parada de execução do script Python no final da função \textit{theBoil}. Cabe ressaltar que esta foi somente uma hipótese e precisa ser testada antes de ser tomada como verdade absoluta. No quesito de recursos de rede, o tráfego foi baixo mesmo com o \textit{overhead} gerado pelo envio de dados desnecessários do servidor para o cliente --- os mesmos dados discutidos com relação ao arquivo de registro da brassagem.



\section{Considerações gerais}

Além disto, notou-se que a integração entre os diversos aspectos do projeto --- parte mecânica, GUI, acionamentos de potência e algoritmo de automação --- foi descomplicada e não causou transtornos. Atribui-se a estas observações a dedicação com que cada ponto foi desenvolvido separadamente.

\section*{Trabalhos futuros}

Isso é para o Relatório Final de defesa.....











