Nesta seção será detalhado o uso da linguagem de programação Javascript no ambiente de interpretação Node.js. O escopo da aplicação desta linguagem no projeto se aplica, mas não é limitado a: acesso ao \textit{hardware}, incluindo barramentos de propósito geral (GPIO) e periféricos como PWM; criação de um servidor web minimalista; e controle do processo de produção de cerveja. Node.js já vem instalado na distribuição padrão do Debian utilizada neste projeto, porém é possível instalar ou atualizar o ambiente por meio do gerenciador de pacotes \textit{apt-get}, conforme descrito na caixa de código-fonte \ref{install_node}:

\lstset{language=bash}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Instalação e/ou atualização do Node.js, label=install_node]
sudo apt-get install nodejs
\end{lstlisting}

Com isto, o gerenciador de pacotes do Node chamado NPM (Node Package Manager) também é instalado no sistema. Neste projeto, o desenvolvimento em Node foi legado do desenvolvimento prévio em PHP e, por isto, tudo foi realizado no diretório \textit{/var/www}, cujo dono é o usuário \textit{www-data}. Em função disto, foi criada manualmente a pasta \textit{/var/www/node\_modules} e o dono foi trocado para o usuário \textit{debian} (enquanto sob condições normais este processo seria automático). Isto foi feito por questões de segurança, uma vez que os módulos do Node são autocontidos no diretório do projeto, o que desencoraja a instalação global na maioria dos casos. O processo de criação do diretório é descrito no trecho de código \ref{create_node_modules}:

\lstset{language=bash}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Criação do diretório \textit{/var/www/node\_modules}, label=create_node_modules]
cd /var/www
sudo mkdir node_modules
sudo chown debian:debian node_modules
\end{lstlisting}

Além disto, foi instalado o módulo \textit{Debug} do Node, que ajuda no desenvolvimento da aplicação da seguinte maneira: ele encapsula a função \texit{console.log}, análoga ao \texit{printf} da linguagem C, de tal maneira que as mensagens só são impressas na tela se uma variável do terminal estiver configurada durante a execução do código. Além disto, diferentes grupos de mensagens de \textit{debug} podem ser configurados, permitindo flexibilidade e também é adotado um esquema de cores que facilita a compreensão das mensagens de \textit{debug}. Para ilustrar o uso deste módulo, na caixa \ref{install_debug} é descrita a instalação do módulo; o trecho de código-fonte \ref{debug_example} descreve como usar o módulo em uma aplicação de Node e a figura \ref{debug_complex} apresenta o resultado do uso do módulo no exemplo, para as seguintes situações: não imprime mensagens de debug; imprime grupos de mensagens de debug e; imprime todas as mensagens de debug disponíveis.

\lstset{language=bash}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Instalação do módulo \textit{Debug}, label=install_debug]
npm install debug
\end{lstlisting}

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Exemplo de uso do módulo \textit{Debug}, label=debug_example]
"use strict";

var dbg_gpio = require('debug')('gpio');
var dbg_pwm = require('debug')('pwm');

console.log("Inicio exemplo:");
for(var i = 0; i < 3; i++){
	switch(i){
	case 0:
		dbg_gpio("Debug situacao gpio");
		break;
	case 1:
		dbg_pwm("Debug situacao pwm");
		break;
	case 2:
		dbg_gpio("Debug ambos gpio");
		dbg_pwm("Debug ambos pwm");
		break;
	}
}
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{./Resources/debug.jpg}
	\captionsetup{justification=centering}
	\caption[Exemplo de uso do módulo \textit{Debug}]{Exemplo de uso do módulo \textit{Debug}}
	\label{debug_complex}
\end{figure}

Neste capítulo deve-se assumir que todas as operações foram realizadas no diretório \textit{/var/www}, salvo indicações em contrário. Note-se também que, no início de todos os códigos-fonte completos, presentes no apêndice \ref{codigos_nodejs}, é usada a delcaração \textbf{"use-strict"}, que evita o uso de potenciais armadilhas do Javascript, como usar inadvertidamente uma variável global sem delcará-la, dentre outras armadilhas.

\subsection{Acesso a GPIO e PWM}
\label{gpio_sec}

O acesso às características de \textit{hardware} da BBB necessárias para o controle das válvulas, bombas, resistores de potência e servo-motor do sistema é feito por meio do módulo de código-aberto \textit{Octalbonescript}, que consiste de um \textit{fork} (ou derivação) do módulo oficial da BBB de acesso a hardware \textit{Bonescript}. Sua escolha se deve ao fato de que esta biblioteca era mais completa e estável durante o desenvolvimento deste projeto. A instalação desta biblioteca está descrita na caixa \ref{install_octalbonescript}. A documentação da API deste módulo foi obtida em \url{https://github.com/theoctal/octalbonescript/wiki}.

\lstset{language=bash}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Instalação do Octalbonescript, label=install_octalbonescript]
npm install octalbonescript
\end{lstlisting}

Uma vez que este módulo compila uma sobreposição de \textit{device tree} a partir de um template fornecido junto com a instalação, foi necessário modificá-lo para acomodar a descrição de hardware do sensor DS18B20. Para tal, foi investigado que o comportamento da biblioteca \textit{Octalbonescript} com relação à \textit{device tree} é o seguinte: se a sobreposição já está carregada não é feita nova compilação do fragmento nem tentativa de carregar a sobreposição, portanto foi necessário resetar a BBB toda vez que novos testes eram realizados. O template fica no diretório \textit{node\_modules/octalbonescript/dts/} e o nome do arquivo modificado é \textit{OBS\_UNIV\_template.dts}. As modificações realizadas, assim como as linhas do código modificadas estão descritas na caixa de código-fonte \ref{octal_dts}. Linhas que começam com "X" foram apagadas, as outras foram adicionadas.

\lstset{language=dtc}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Modificações feitas ao template de \textit{device tree} do Octalbonescript, label=octal_dts]
[389]        /* P9_11 (THE ONE-WIRE DS18B20) */
[390]        bb_w1_pins: pinmux_bb_w1_pins {
[391]           pinctrl-single,pins = <0x070  0x37>; };     /* Mode 7, Pull-Up, RxActive */
X[392]        P9_11_gpio_pin: pinmux_P9_11_gpio_pin {
X[393]           pinctrl-single,pins = <0x070  0x2F>; };     /* Mode 7, RxActive */
X[394]        P9_11_gpio_pu_pin: pinmux_P9_11_gpio_pu_pin {
X[395]           pinctrl-single,pins = <0x070  0x37>; };     /* Mode 7, Pull-Up, RxActive */
X[396]        P9_11_gpio_pd_pin: pinmux_P9_11_gpio_pd_pin {
X[397]           pinctrl-single,pins = <0x070  0x27>; };     /* Mode 7, Pull-Down, RxActive */
X[398]        P9_11_uart_pin: pinmux_P9_11_uart_pin {
X[399]           pinctrl-single,pins = <0x070  0x36>; };     /* Mode 6, Pull-Up, RxActive */
[879]        onewire@0 {
[880]           compatible = "w1-gpio";
[881]           status = "okay";
[882]           pinctrl-names = "default";
[883]           pinctrl-0 = <&bb_w1_pins>;
X[884]           pinctrl-1 = <&P9_11_gpio_pin>;   gpios = <&gpio1 30 0>;
X[885]           pinctrl-2 = <&P9_11_gpio_pu_pin>;
X[886]           pinctrl-3 = <&P9_11_gpio_pd_pin>;
X[887]           pinctrl-4 = <&P9_11_uart_pin>;
[888]        };
X[1232]        P9_11 {
X[1233]           gpio-name = "P9_11";
X[1234]           gpio = <&gpio1 30 0>;
X[1235]           input;
X[1236]           dir-changeable;
X[1237]        };
\end{lstlisting}

Com esta configuração da \textit{device tree}, foi preciso parar de carregar o fragmento descrito na seção \ref{ds18b20_dev_tree}, pois ao tentar usar o \textit{Octalbonescript} passou a ocorrer um erro do tipo \textbf{EEXIST: file already exists}, que indica em um âmbito geral que um arquivo que deveria ser criado já existe.

A partir deste ponto, foi desenvolvido um módulo nomeado \textit{gpio\_config} responsável pelo gerenciamento de GPIO e PWM, baseado no \texit{Octalbonescript}. Foram criados objetos para cada elemento do sistema, usados para guardar a identificação do pino de GPIO de cada objeto, o estado e a configuração de cada pino. Para isto, uma função auxiliar foi criada. Também foi criado um objeto que reúne todos os objetos dos pinos, para facilitar a configuração inicial e também manter controle sobre o status do sistema durante seu funcionamento. Uma vez que em Node as variáveis são todas ponteiros, ao atribuir uma variável a outra o que se está fazendo é apontar as duas variáveis para o mesmo endereço de memória. Na caixa de código-fonte \ref{gpio_variables} é apresentada a função de criação dos objetos, a declaração dos elementos aquecedores e a união destes elementos, a título de exemplo. A descrição completa das declarações de objetos pode ser encontrada no código-fonte \ref{gpio_cfg} no apêndice \ref{codigos_nodejs}.

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Criação de objetos para os elementos do sistema em Node, label=gpio_variables]
var mash_heat = module.exports.mash_heat = new PinObjectIO("P8_13");
var boil_heat = module.exports.boil_heat = new PinObjectIO("P8_14");
var heaters = module.exports.heaters = collect(mash_heat, boil_heat);

// I/O pins
function PinObjectIO(pinId){//function to create pin object, should recieve pin ID
	if(pinId){//if the variable is passed to function or not empty
		this.id = pinId; this.state = b.LOW; this.cfg = b.OUTPUT;
	}
	else{//if no variable is passed or passed empty
		debug("No variable passed to create pin object");
	}
}

function collect() {//function concat objects
	var ret = {};//the new object
	var len = arguments.length;//the total number of objects passed to collect
	for (var i=0; i<len; i++) {//do it for every object passed
		for (var p in arguments[i]) {//iterate the i-eth object passed
			if (arguments[i].hasOwnProperty(p)) {//whenever there is a property
				ret[p] = arguments[i][p];//add the property to the new object
			}
		}
	}
	return ret;
}
\end{lstlisting}

Além disto, foi criado um objeto que guarda o status do sistema: o número total de pinos a serem configurados, o número de pinos configurados corretamente, o número de pinos como GPIO, PWM, analógicos e interrupções. Quanto às funcões do módulo, estas são:

\begin{itemize}
	\item \textbf{changeStatusIO(pin, val)} --- recebe o nome do pino, e.g. \textit{mash\_heat}, e o valor (\textit{true} ou \textit{false} para GPIO e numérico para PWM). Ajusta o valor do pino conforme passado para a função, assim como trata de atualizar as variáveis de controle dos pinos.
	\item \textbf{getSystemStatus()} --- retorna o valor/estado de todos os pinos do sistema, sendo 0 ou 1 para GPIO e numérico para PWM.
	\item \textbf{pinsConfiguration()} --- configura todos os pinos declarados como entrada, saída ou PWM. Em caso de erro de configuração de algum pino é impressa uma mensagem com o auxílio do módulo \textit{debug}, portanto cabe ao administrador do sistema testar se a configuração está funcionando no momento da instalação do equipamento ou quando julgar necessário.
	\item \textbf{ioTest()} --- função de teste. Implementa um algoritmo que seta os pinos de GPIO do sistema de tal forma sequencial, ou seja, chamando esta função em um \textit{loop} faz com que um efeito cascata seja produzido, caso os pinos estejam ligados a LEDs.
\end{itemize}

Na função \textit{pinsConfiguration}, é preciso notar que dentro do laço de repetição \textit{for} é chamada uma função anônima para a configuração de cada pino. Isto é necessário pois, se todas as operações fossem realizadas diretamente dentro do laço, o comportamento assíncrono do Node geraria inconsistências na execução do código. Assim sendo, o objetivo da função anônima é criar um escopo que permite a execução assíncrona do código sem que a referência passada para esta função anônima se degenere. Uma vez que esta função precisa receber o valor e não o ponteiro da variável de iteração do laço, tanto o pino a ser configurado quanto o seu índice (variável de iteração) no laço de repetição são passados com o auxílio do método \textit{call()}, que neste caso copia o pino como o elemento \texit{this} e o índice como o primeiro argumento da função, criando um novo escopo por meio de uma clausura. Sem isso, antes que a primeira invocação da função anônima acabasse, o valor de i, por exemplo, já seria \textit{all\_io\_objects.length} e não zero, que seria o valor esperado.

Para tornar a compreensão desta necessidade mais clara, a caixa de código-fonte \ref{call_this} apresenta um exemplo no qual duas funções com um laço \textit{for} são chamadas: a primeira delas imprime o valor da variável de iteração para todas as chamadas do laço imediatamente e com um atraso de 100ms, mas sem precauções com relação ao comportamento assíncrono do Node; já a segunda função utiliza o método descrito no parágrafo anterior. Observa-se na figura \ref{res_call_this} que sem tomar precauções, na chamada com atraso, é impresso o último valor da variável de iteração do laço em todas as iterações. Isto deixa claro a necessidade de criar um novo escopo, assim como demonstra que esta é uma fonte de erros para programadores inexperientes e/ou descuidados.

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Uso de clausura para criação de escopo, label=call_this]
'use-strict';
var debug1 = require('debug')('debug1');
var debug2 = require('debug')('debug2');

function pinConfiguration() {
        for(var i = 0; i < 3; i++){
                setTimeout(function() { debug1('atraso: ' + i); }, 100);
                debug1('imediato: ' + i);
        }
}

function pinConfiguration2() {
        for(var i = 0; i < 3; i++){
                (function () {
                        var i2 = this;
                        setTimeout(function() { debug2('atraso: ' + i2);}, 100);
                }).call(i);
                debug2('imediato: ' + i);
        }
}

pinConfiguration2();
pinConfiguration();
\end{lstlisting}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.65]{./Resources/call_this.jpg}
	\captionsetup{justification=centering}
	\caption[Resultado de chamada de função sem criação de escopo x com criação de escopo]{Resultado de chamada de função sem criação de escopo x com criação de escopo}
	\label{res_call_this}
\end{figure}

\subsection{Servidor Express.js}
\label{servidor_sec}

Mesmo com o servidor Apache já configurado na BBB, quando foi decidido o uso de Node.js como linguagem do servidor o Apache foi substituído pelo \textit{Framework} Express, dados os benefícios apontados na seção \ref{node_js_sec}. Para isto, a consulta à documentação da API deste framework (\url{http://expressjs.com/pt-br/4x/api.html}) foi a base de desenvolvimento do servidor. 

Outros dois módulos auxiliares foram empregados em conjunto com o Express: o módulo \textit{Body-parser}, cuja função é a interpretação de dados codificados em JSON pelo cliente; e o módulo \textit{PHP-express}, que permite a interpretação de arquivos PHP pelo servidor. Este último módulo foi empregado devido a algumas funcionalidades desenvolvidas em PHP em uma fase inicial do projeto, portanto suportando a aplicação legada. Reescrever os códigos PHP é uma opção, porém em função do tempo necessário para tal tarefa, esta foi a solução adotada. Na caixa \ref{install_express} é documentada a instalação dos módulos.

\lstset{language=bash}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Instalação dos módulos necessários para implementar o servidor web em Node.js, label=install_express]
npm install express
npm install body-parser
npm install php-express
\end{lstlisting}

O código-fonte no qual é configurado o servidor é o \textit{/var/www/controle.js}, que é também o arquivo raiz da aplicação em Node, e está disponível no apêndice \ref{controle_js}. É interessante observar a configuração do PHP-express, descrita no trecho de código-fonte \ref{php_express}, no qual observa-se que logo ao adicionar o módulo ao código é passado o caminho do PHP, que deve ser previamente instalado no sistema. Também é notável o fato de que os arquivos PHP são identificados por meio de uma expressão regular, cuja função à qual ela é aplicada direciona estes arquivos para o \textit{engine} do PHP.

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Configuração do PHP-express, label=php_express]
var phpExpress = require('php-express')({  // assumes php is in your PATH
  binPath: 'php'
});

// set view engine to php-express
app.set('views', './');
app.engine('php', phpExpress.engine);
app.set('view engine', 'php');
 
// routing all .php file to php-express
app.all(/.+\.php$/, phpExpress.router);
\end{lstlisting}

Com relação à configuração do Express, três pontos devem ser notados: o diretório no qual é executada a aplicação é configurado como o diretório raiz do servidor, seja para servir arquivos HTML e CSS ou arquivos de mídia e apoio da aplicação; o endereço de IP e porta são especificados de modo a permitir acesso à BBB pela internet e; são configuradas rotas para diferentes categorias de requisições do cliente. O fragmento de código-fonte \ref{express_server} apresenta os três pontos discutidos neste parágrafo. Note-se que é adicionado o módulo \textit{routes}, que foi escrito separadamente somente para facilitar a compreensão do código. Ele define o comportamento das rotas.

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Configuração do servidor web com o \textit{framework} Express.js, label=express_server]
var express = require("express");
var app = express();
var routes = require('./my_node_modules/routes.js');

app.use(express.static(__dirname));//add the directory where HTML and CSS files are
var server = app.listen(8587, "192.168.1.155", function () {//listen at the port and address
	var host = server.address().address;
	var port = server.address().port;
	var family = server.address().family;
	debug('Express server listening at http://%s:%s %s', host, port, family);
});

app.route('/controle')//used to unite all the requst types for the same route
.post(routes.controleRoute);

app.route('/startrecipe')//used to unite all the requst types for the same route
.post(routes.startrecipeRoute);

app.route('/config')//used to unite all the requst types for the same route
.post(routes.configRoute);

app.route('/clientrequest')//used to unite all the requst types for the same route
.post(routes.clientrequestRoute);
\end{lstlisting}

Quanto ao módulo que define o comportamento das rotas do servidor, seu código-fonte é apresentado na caixa de código-fonte do apêndice \ref{rotas_js}. Ele consiste de quatro funções --- uma para cada rota:

\begin{itemize}
	\item \textbf{controleRoute(req, res)} --- realiza o controle direto de GPIO e PWM. Faz uso do módulo \textit{gpio\_cfg}, descrito na seção \ref{gpio_sec}.
	\begin{itemize}
		\item Muda o valor de um terminal, conforme especificado pelo cliente.
		\item Retorna para o cliente o status de todos os pinos da aplicação, independente da sua configuração.
	\end{itemize}
	\item \textbf{startRecipeRoute(req, res)} --- executa diversas funções relacionadas à produção de cerveja, inclusive iniciar o processo de controle da mesma, conforme a requisição enviada pelo cliente.
	\begin{itemize}
		\item Retorna a lista de receitas cadastradas no servidor.
		\item Verifica integridade da receita, ou seja, se ela contém informações suficientes para que uma produção seja iniciada.
		\item Realiza uma série de verificações e começa uma brassagem, se aprovado.
		\item Verifica se já existe alguma receita em andamento.
		\item Retorna erro para o cliente se nenhuma requisição é válida.
	\end{itemize}
	\item \textbf{configRoute(req, res)} --- ajusta ou responde com a data e hora da BBB, conforme a solicitação do cliente.
	\item \textbf{clientrequestRoute(req, res)} --- função auxiliar do processo de mostura, usada para sinalizar que um novo degrau de temperatura deve começar.
\end{itemize}

Dentre as particularidades de implementação deste módulo, observa-se o uso dos argumentos \textit{req} e \textit{res} em todas as funções, uma vez que estes são padronizado pela API do Express para requisições do tipo POST feitas pelo cliente. O argumento \textit{req} contém todos os dados enviados pelo cliente no padrão HTTP POST, que é parte da transferência de estado representacional, conhecida como REST. Uma vez que o módulo Express está em conformidade com as restrições REST, ele é considerado um serviço \textit{RESTful}. Quanto ao argumento \textit{res}, este contém o objeto responsável por enviar a resposta do servidor para o cliente após o processamento da requisição, que é conseguida por meio método \textit{send}. É importante observar que, neste projeto, todas as requisições do cliente e respostas do servidor são feitas usando a codificação de dados JSON. 

O exemplo expresso na caixa de código-fonte \ref{exemplo_reqres} demonstra o uso dos argumentos \textit{req} e \textit{res} descritos nesta seção. Foi assumido que são recebidos os dados \textit{comando} e \textit{valor}. Se o comando for "inverter", é chamada a função que inverte um botão, cuja resposta pode ser \textit{erro1} ou \textit{sucesso}. Ainda, se o comando for diferente de "inverter", a resposta é \textit{erro2}.

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Exemplo de uso dos argumentos \textit{req} e \textit{res} definidos pelo Express.js, label=exemplo_reqres]
function processaRequisicaoPost(req, res) {
	var comando = req.body.comando;
	var botao = req.body.valor;

	if(comando == "inverter"){
		inverteBotao(botao, function(err){
			if (err) res.send('{"resposta":"erro1"}'); return;
			res.send('{"resposta":"sucesso"}');
		});
	}
	else res.send({"resposta":"erro2"});
};
\end{lstlisting}

Também é importante entender o uso dos módulos \textit{fs} e \textit{child\_process} incluídos por padrão no Node.js e cuja documentação da API pode ser obtida no site do Node.js (\url{https://nodejs.org/dist/latest-v4.x/docs/api/}). O módulo \textit{fs} implementa o acesso ao sistema de arquivos, com funções de leitura e escrita a arquivos, mudança de dono ou modo de execução, criação e leitura de diretórios, dentre outras. Quanto à leitura e escrita de arquivos, esta pode ser realizada de forma assíncrona ou síncrona --- usuários que ainda estão no processo de aprendizado de orientação a eventos tendem a usar a versão síncrona, porém isto deve ser evitado, uma vez que faz o bloqueio da execução da aplicação enquanto o arquivo não acabar de ser acessado.

Já o módulo \textit{child\_process} permite a criação de processos filhos do Node, que são executados independentemente deste: basicamente é possível executar uma linha de comando ou script do \textit{shell} independente do Node. Neste módulo, foi utilizada a função \textit{exec} para ajustar a data e hora da BBB após receber uma requisição do cliente, por meio dos comandos \textbf{date -s} e \textbf{hwclock -w}, que ajusta a data e hora do sistema e sincroniza com o RTC do sistema, respectivamente. A implementação desta funcionalidade pode ser verificada na função \textit{configRoute} do código-fonte \ref{rotas_js}, encontrado no apêndice \ref{codigos_nodejs}.

\subsection{Registros e verificações em geral}
\label{registros_sec}

Para as funções de registro, ou \textit{log}, e de verificações, além de eventuais funções de miscelânea, foi escrito um módulo separado, cujo código-fonte está documentado na caixa \ref{log_check_misc_js} do apêndice \ref{codigos_nodejs}. AS funções e suas respectivas descrições são apresentadas:

\begin{itemize}
	\item \textbf{startTemperatureLogging()} --- inicia o script Python descrito na seção \ref{python_sec}, por meio de um processo filho do Node.
	\begin{itemize}
		\item Tenta deletar o arquivo que contém a última leitura de temperatura (\textit{/var/www/datalog/instant.csv}) antes de iniciar o script em Python.
		\item Define o comportamento caso o script pare de ser executado: imprime uma mensagem de debug.
	\end{itemize}
	\item \textbf{stopTemperatureLogging()} --- aborta a execução do script Python iniciado por \textit{startTemperatureLogging}.
	\item \textbf{getTemperatureReading(logFilePath, logReadHandler, callback)} --- lê a mais recente amostragem de temperatura, que está salva no arquivo especificado pelo argumento \textit{logFilePath}. Além da descrição aqui apresentada, o funcionamento desta função está descrito no algoritmo da figura \ref{algoritmo_tempread}
	\begin{itemize}
		\item Recebe como argumento uma função de callback padrão, ou seja, cujo primeiro argumento é o possível erro e o segundo argumento é o valor de temperatura obtido em caso de sucesso.
		\item O argumento \textit{logReadHandler} é um objeto externo à função e que deve guardar o valor da última leitura de temperatura, as últimas 5 \textit{timestamps} (registros de data/hora) e a contagem de erros de leitura de temperatura referentes a um sensor específico.
		\item Se há algum problema na leitura do arquivo que deve conter o registro da última temperatura lida, a variável de erro é incrementada e, se a contagem exceder 180 erros, a mensagem de erro da função de \textit{callback} indica que muitos erros foram detectados. Note-se que 180 é um valor quase que arbitrário que pode representar 3 minutos de leituras consecutivas erradas ou 180 erros esporádicos de leitura do arquivo e cuja escolha foi realizada pois representa 5\% das amostras contidas em uma hora e que, por sua vez, é aceito como o tempo mínimo de uma brassagem ou fervura. Os testes não foram levados à exaustão, mas há espaço para a realização de ensaios para determinação de um valor mais adequado. 
		\item Em caso de leitura do arquivo com sucesso, se a formatação do valor lido estiver errada, imprime erro, incrementa a variável de erro e, no caso de a contagem exceder 180, seta a mensagem de erro da função de \textit{callback} indicando que muitos erros foram detectados.
		\item Se o valor lido for consistente, atualiza o objeto \textit{logReadHandler}. Compara as últimas 5 \textit{timestamps} obtidas e incrementa a variável de erro se todas elas forem coincidentes --- isto indica primariamente que o sensor de temperatura está mal conectado, ou mesmo desconectado em caso de erros consecutivos. Por isto a mensagem de erro da \textit{callback} retorna a possibilidade de problemas com o sensor. No caso de a contagem de erros exceder 180, a mensagem de erro da função de \textit{callback} indican que muitos erros foram detectados ao invés de avisar sobre o sensor.
		\item Por fim, se a leitura do registro de temperatura passar por todas as checagens, é retornado nulo na mensagem de erro e o valor de temperatura como segundo argumento. 
	\end{itemize}
	\item \textbf{checkRecipeIntegrity(recipe, path, res)} --- Verifica a integridade da receita selecionada pelo usuário antes de permitir o início de uma brassagem. Os argumentos recebidos pela função são o nome da receita, o diretório de receitas a ser verificado e o objeto que contém a resposta da requisição AJAX feita pelo cliente, respectivamente.
	\begin{itemize}
		\item Se não consegue ler o arquivo da receita, responde com erro ao cliente.
		\item Caso contrário, lê o arquivo \textit{lockfile} para verificar se já existe uma brassagem em andamento. Se não consegue ler o \textit{lockfile} ou ele indica que há uma brassagem em andamento, também responde com erro.
		\item Verifica a consistência da receita com o seguinte critério: há campos estritamente necessários para a produção e que impedem o início da receita se estiverem em branco, campos que geram avisos mas permitem o início de uma receita após o usuário se declarar ciente e campos indiferentes para o sistema. São os campos estritamente necessários: água de brassagem, tempo da fervura, temperatura inicial de brassagem, primeiro degrau de temperatura, tempo do primeiro degrau, malte 1, quantidade do malte 1, lúpulo 1, quantidade do lúpulo 1 e tempo de adição do lúpulo 1. Os campos que geram avisos são: nome da receita, estilo, levedura, água de sparging e temperatura de sparging. Todos os outros campos são indiferentes à verificação de consistência da receita.
		\item Se tudo deu certo, uma variável global é setada para registro e uso posterior.
	\end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.55]{./Resources/algoritmo_tempread.png}
	\captionsetup{justification=centering}
	\caption[Representação em fluxograma do algoritmo de implementação da função \textit{getTemperatureReading}]{Representação em fluxograma do algoritmo de implementação da função \textit{getTemperatureReading}}
	\label{algoritmo_tempread}
\end{figure}

\begin{itemize}
	\item \textbf{logToFile(message, code, notableTimestamp)} --- função que realiza registro do status da brassagem sempre que invocada. Basicamente, ela salva a variável global \textit{environmentVariables} em um arquivo de texto.
	\begin{itemize}
		\item O argumento \textit{message} pode conter uma string com uma mensagem explicativa com, por exemplo, a situação ou estágio da brassagem em que ocorreu o registro, mas pode também ser deixado em branco. O argumento \textit{code} tem basicamente o mesmo propósito, mas é um número predefinido para cada situação possível da brassagem, que permite que o arquivo de registro possa ser interpretado com maior facilidade; por este motivo, recomenda-se veementemente que não seja deixado em branco. A tabela \ref{significados_log} apresenta a correspondência entre os valores do argumento \textit{code} e seus significados.
		\item O argumento \textit{notableTimestamp} é usado para indicar quando uma situação notável ocorreu, como por exemplo o início da brassagem, o final de uma rampa ou degrau de temperatura, o início da fervura, etc. Para todas as outras situações deve ser deixado em branco, sendo que as situações notáveis são predefinidas.
		\item O objeto \textit{environmentVariables}, declarado no código-fonte raiz da aplicação em Node, que foi abordado na seção \ref{servidor_sec} e pode ser obtido no apêndice \ref{codigos_nodejs}, também é descrito na caixa \ref{environment_code}. Ele é salvo no arquivo de \textit{log} no formato JSON e para isto é empregada a função \textit{JSON.stringify} conforme descrito na linha de código-fonte exibida na caixa \ref{json_stringify}.
	\end{itemize}
	\item \textbf{sendRecipeNames(path, res)} --- responde para o cliente usando o objeto \textit{res} com todas as receitas disponíveis no diretório passado como argumento \textit{path} para a função.
	\begin{itemize}
		\item É preciso notar que, quando uma receita é deletada, a única modificação realizada é que a extensão do arquivo \textit{.recipe} é modificada para \textit{.recipe.del}, assim é fácil recuperar a receita caso o usuário a tenha deletado por engano. Por isso nesta função, além de ler os nomes dos arquivos presentes no diretório e excluir a extensão, foi preciso excluir os arquivos deletados.
	\end{itemize}
\end{itemize}

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Declaração do objeto \textit{environmentVariables}, que contém o status instantâneo da brassagem, label=environment_code]
//global variables that should also be saved to a backup file periodically
global.environmentVariables = {
	warn: "",//if not empty holds some warning message
	code: "",//tells the same as msg, but as an index, easier to check programatically
	tmpMT: "",//mash tun temperature
	tmpMTsetp: "",//mash tun current setpoint
	tmpBK: "",//brewing kettle temperature, also the "hot liquor tank" for sparging
	tmpBKsetp: "",//brewing kettle/hot liquor tank current setpoint
	timeLeft: "",//helping variable to tell the client the time left for the step rests or the boil, etc
	readyForNextStep: false,//set whenever the system is ready for the next step
	auto: true, //whether the process control is running automatically or there is human intervention
	processFail: false,//flag is set if the process fails irreversibly
	msg: "",//holds some explanatory message
	timestamps:{//notable timestamps
		start: "",//epoch time of the first request to start a recipe
		startHeating: "",//epoch time of the start to heat the mash water
		finishHeating: "",//epoch for the finish of the heating of mash water
		//start of the ramps
		sRamp0: "", sRamp1: "", sRamp2: "", sRamp3: "", sRamp4: "", sRamp5: "", sRamp6: "", sRamp7: "",
		//finish of the ramps
		fRamp0: "", fRamp1: "", fRamp2: "", fRamp3: "", fRamp4: "", fRamp5: "", fRamp6: "", fRamp7: "",
		startDrain: "",//start of the sparging process, when the mash is parcially drained to the BK
		startSparge: "",//here the recirculation pump starts working
		heatingBoil: "",//started to heat the wort after sparging
		boilStart: "",//time when temperature is near enough boiling (>96°C)
		boilFinishScheduled: "",//time when the boil is scheduled to finish
		curr: "", //epoch time of the current variables state
	},
	ioStatus: gpioCfg.all_io,//also records the IO status
	okToStart: false, //true if a recipe is ok enough to start a production
	recipe: "" //recipe name
};
\end{lstlisting}

\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Uso da função \textit{JSON.stringify} para codificar um objeto em string JSON, label=json_stringify]
dataToSave = JSON.stringify(global.environmentVariables) + "\n";
\end{lstlisting}

\begin{center}
	\begin{table}[H]
		\centering
		\captionsetup{justification=centering}
		\caption[Correspondência entre o valor numérico e o significado dos códigos usados para registro da brassagem]{Correspondência entre o valor numérico e o significado dos códigos usados para registro da brassagem}
		\label{significados_log}
		\begin{tabular}{ | M{2cm} | M{13cm} |}
			\hline
			\textbf{Valor} & \textbf{Significado} \\ \hline
			
			0 & requisição para início da brassagem \\ \hline
			1 & produção iniciada \\ \hline
			2 & esquentando água da mostura \\ \hline
			3 & esperando adição dos grãos \\ \hline
			4 & rampa da mostura em execução \\ \hline
			5 & degrau da mostura em execução \\ \hline
			6 & \textit{sparging} em execução \\ \hline
			7 & transbordamento da MT \\ \hline
			8 & esquentando mosto para a fervura \\ \hline
			9 & fervendo o mosto \\ \hline
			10 & lúpulo adicionado \\ \hline
			11 & \\ \hline
			11 & \\ \hline
			11 & \\ \hline
			11 & \\ \hline
			11 & \\ \hline

		\end{tabular}
	\end{table}
\end{center}

\subsection{Controle do processo de brassagem}

O módulo responsável pelo controle do processo de brassagem é o \textit{ctrl.js}, cujo código-fonte está disponível no apêndice \ref{codigos_nodejs}, na caixa de código-fonte \ref{ctrl_js}. É importante ressaltar que, embora o comportamento do Node.js seja assíncrono o processo de brassagem é sequencial, o que implica no uso de diversas funções de \textit{callback} aninhadas. No intuito de evitar o \textit{inferno de callbacks}, apresentado na seção \ref{node_js_sec}, este processo sequencial foi quebrado em algumas funções que implementam a funcionalidade do módulo e outras auxiliares. Seu funcionamento e aspectos chave são discutidos na presente seção.

A primeira função do processo de controle é a \textit{startMashingProcess(recipe, res, lockFile, recipesPath, callback)}, invocada a partir de uma requisição do cliente e, portanto, sua chamada está presente no módulo referente às rotas do Express, discutido na seção \ref{servidor_sec}. Ela recebe como parâmetros o nome da receita iniciada, o objeto de resposta da requisição AJAX, o caminho para o arquivo \textit{lockfile}, o caminho para o diretório das receitas e uma função de \textit{callback}. Em primeiro lugar é verificada a flag global \textit{global.environmentVariables.okToStart} que indica se a receita está pronta para ser executada --- esta flag é setada previamente pela função \textit{checkRecipeIntegrity}, descrita na seção \ref{registros_sec} e chamada durante o processo de interação pré-brassagem do usuário com o sistema. Depois disto, também é verificado se o nome da receita passado como argumento é idêntico ao da variável global de controle \textit{global.environmentVariables.recipe}.

Caso as verificações iniciais sejam positivas, é escrito o valor "1" no arquivo \textit{lockfile}, indicando daqui para a frente que há uma brassagem em andamento. O conteúdo da receita é lido em uma variável e o \textit{log} de temperatura é iniciado, ou seja, o script Python é invocado como um processo filho do Node. Também é feito o \textit{log} inicial do processo de brassagem. Se tudo ocorreu sem erros, o servidor envia uma resposta para o cliente indicando sucesso, chama a função de \textit{callback} com a variável erro nula e invoca a função \textit{heatMashWater}, que dá prosseguimento ao controle do processo. Em caso de erro em alguma das situações descritas, é enviada uma resposta de erro para o cliente e a função de \textit{callback} é invocada com a variável erro indicando o erro ocorrido. Note-se que a função de \textit{callback} não tem importância no que diz respeito ao controle, mas serve somente para retornar o status da tentativa de início da produção.

A função \textit{heatMashWater(recipeContents)} recém chamada, dá prosseguimento ao controle da brassagem. Como o seu nome sugere, ela é resposável pelo aquecimento da água da brassagem até que ela atinja a temperatura inicial, mantendo este \textit{setpoint} até que o usuário adicione os maltes à MT. O único argumento que a função recebe é o conteúdo da receita, a partir do qual é obtido o \textit{setpoint}. Inicialmente a bomba de recirculação é ligada e é feito um \textit{log} da brassagem que anota a timestamp notável de inicio de aquecimento.

São iniciados dois laços de repetição: um que faz um \textit{log} da situação da brassagem a cada 5 segundos e outro que é repetido a cada 1 segundo e que lê a temperatura da água e chama a função auxiliar \textit{updateHeatingConditions} para controlar o elemento aquecedor da MT. No \textit{callback} da \textit{updateHeatingConditions} fica definido que, se esta é a primeira vez que a temperatura desejada é atingida, o laço de repetição do \textit{log} é atualizado para refletir a mudança de situação de "esquentado água da brassagem" para "esperando adição dos maltes". Se não é a primeira vez que é atingido o \textit{setpoint}, a \textit{callback} não faz nada. Em resumo, após a temperatura atingir o valor desejado, ela é mantida até que o usuário adicione os maltes.

Concomitantemente, o laço de controle de temperatura da função \textit{heatMashWater} verifica a \textit{flag} global \textit{global.environmentVariables.readyForNextStep} que só é setada após o usuário indicar, por meio da GUI, que ele adicionou os maltes. Quando isto acontece, a flag é zerada e os laços de \textit{log} e de controle são interrompidos. Por fim é chamada a função de controle de rampas e degraus de temperatura, mas antes de entrar nos seus detalhes de funcionamento, será explicada a função auxiliar \textit{updateHeatingConditions(vessel, setp, temperature, callback)}, uma vez que já foi feito uso dela.

Os argumentos que ela recebe possuem uma interpretação bem direta: \textit{vessel} é o recipiente a ser controlado, ou seja, pode ser a MT ou o BK; \textit{setp} e \textit{temperature} são respectivamente a temperatura desejada e a atual e; \textit{callback} é a função executada sempre que a temperatura é maior ou igual ao valor do setpoint, e cujo argumento passado para ela é nulo. O controle do elemento aquecedor é implementado da seguinte forma: quando a temperatura está abaixo de 70\% do \textit{setpoint}, o aquecimento fica ligado 100\% do tempo; quando a temperatura está entre 70\% e 90\% do \textit{setpoint}, o aquecimento fica ligado 66\% do tempo; quando a temperatura está entre 90\% e 100\% do \textit{setpoint}, o aquecimento fica ligado 33\% do tempo e; acima disto o aquecimento fica desligado. Cabe ressaltar que a vantagem desta função auxiliar não é o sistema de controle de aquecimento, mas sim o fato de que este é auto-contido, ou seja, para quaisquer implementações de controle de temperatura (PID, histerese, direto), basta modificar esta função, sem alteração do resto do código. Outra condição que deve ser atendida é que esta função precisa ser chamada periodicamente dentro de um laço de repetição, uma vez que ela somente atualiza o valore da saída (elemento aquecedor) baseada nas entradas (temperatura e \textit{setpoint}).



\subsection{Simulação do controle do processo de brassagem}
\label{simulacao_controle}


















