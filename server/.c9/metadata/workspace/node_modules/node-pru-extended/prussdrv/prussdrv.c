{"changed":true,"filter":false,"title":"prussdrv.c","tooltip":"/node_modules/node-pru-extended/prussdrv/prussdrv.c","value":"/*\n * prussdrv.c\n *\n * User space driver for PRUSS\n *\n * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/\n *\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *    Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n *    Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the\n *    distribution.\n *\n *    Neither the name of Texas Instruments Incorporated nor the names of\n *    its contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n*/\n\n\n/*\n * ============================================================================\n * Copyright (c) Texas Instruments Inc 2010-12\n *\n * Use of this software is controlled by the terms and conditions found in the\n * license agreement under which this software has been supplied or provided.\n * ============================================================================\n */\n\n\n#include <prussdrv.h>\n#include \"__prussdrv.h\"\n#include <stdio.h>\n\n#ifdef __DEBUG\n#define DEBUG_PRINTF(FORMAT, ...) fprintf(stderr, FORMAT, ## __VA_ARGS__)\n#else\n#define DEBUG_PRINTF(FORMAT, ...)\n#endif\n\n#define PRUSS_UIO_PRAM_PATH_LEN 128\n#define PRUSS_UIO_PARAM_VAL_LEN 20\n#define HEXA_DECIMAL_BASE 16\n\nstatic tprussdrv prussdrv;\n\nint __prussdrv_memmap_init(void)\n{\n    int i, fd;\n    char hexstring[PRUSS_UIO_PARAM_VAL_LEN];\n\n    if (prussdrv.mmap_fd == 0) {\n        for (i = 0; i < NUM_PRU_HOSTIRQS; i++) {\n            if (prussdrv.fd[i])\n                break;\n        }\n        if (i == NUM_PRU_HOSTIRQS)\n            return -1;\n        else\n            prussdrv.mmap_fd = prussdrv.fd[i];\n    }\n    fd = open(PRUSS_UIO_DRV_PRUSS_BASE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.pruss_phys_base =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n    fd = open(PRUSS_UIO_DRV_PRUSS_SIZE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.pruss_map_size =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n\n    prussdrv.pru0_dataram_base =\n        mmap(0, prussdrv.pruss_map_size, PROT_READ | PROT_WRITE,\n             MAP_SHARED, prussdrv.mmap_fd, PRUSS_UIO_MAP_OFFSET_PRUSS);\n    prussdrv.version =\n        __pruss_detect_hw_version(prussdrv.pru0_dataram_base);\n\n    switch (prussdrv.version) {\n    case PRUSS_V1:\n        {\n            DEBUG_PRINTF(PRUSS_V1_STR \"\\n\");\n            prussdrv.pru0_dataram_phy_base = AM18XX_DATARAM0_PHYS_BASE;\n            prussdrv.pru1_dataram_phy_base = AM18XX_DATARAM1_PHYS_BASE;\n            prussdrv.intc_phy_base = AM18XX_INTC_PHYS_BASE;\n            prussdrv.pru0_control_phy_base = AM18XX_PRU0CONTROL_PHYS_BASE;\n            prussdrv.pru0_debug_phy_base = AM18XX_PRU0DEBUG_PHYS_BASE;\n            prussdrv.pru1_control_phy_base = AM18XX_PRU1CONTROL_PHYS_BASE;\n            prussdrv.pru1_debug_phy_base = AM18XX_PRU1DEBUG_PHYS_BASE;\n            prussdrv.pru0_iram_phy_base = AM18XX_PRU0IRAM_PHYS_BASE;\n            prussdrv.pru1_iram_phy_base = AM18XX_PRU1IRAM_PHYS_BASE;\n        }\n        break;\n    case PRUSS_V2:\n        {\n            DEBUG_PRINTF(PRUSS_V2_STR \"\\n\");\n            prussdrv.pru0_dataram_phy_base = AM33XX_DATARAM0_PHYS_BASE;\n            prussdrv.pru1_dataram_phy_base = AM33XX_DATARAM1_PHYS_BASE;\n            prussdrv.intc_phy_base = AM33XX_INTC_PHYS_BASE;\n            prussdrv.pru0_control_phy_base = AM33XX_PRU0CONTROL_PHYS_BASE;\n            prussdrv.pru0_debug_phy_base = AM33XX_PRU0DEBUG_PHYS_BASE;\n            prussdrv.pru1_control_phy_base = AM33XX_PRU1CONTROL_PHYS_BASE;\n            prussdrv.pru1_debug_phy_base = AM33XX_PRU1DEBUG_PHYS_BASE;\n            prussdrv.pru0_iram_phy_base = AM33XX_PRU0IRAM_PHYS_BASE;\n            prussdrv.pru1_iram_phy_base = AM33XX_PRU1IRAM_PHYS_BASE;\n            prussdrv.pruss_sharedram_phy_base =\n                AM33XX_PRUSS_SHAREDRAM_BASE;\n            prussdrv.pruss_cfg_phy_base = AM33XX_PRUSS_CFG_BASE;\n            prussdrv.pruss_uart_phy_base = AM33XX_PRUSS_UART_BASE;\n            prussdrv.pruss_iep_phy_base = AM33XX_PRUSS_IEP_BASE;\n            prussdrv.pruss_ecap_phy_base = AM33XX_PRUSS_ECAP_BASE;\n            prussdrv.pruss_miirt_phy_base = AM33XX_PRUSS_MIIRT_BASE;\n            prussdrv.pruss_mdio_phy_base = AM33XX_PRUSS_MDIO_BASE;\n        }\n        break;\n    default:\n        DEBUG_PRINTF(PRUSS_UNKNOWN_STR \"\\n\");\n    }\n\n    prussdrv.pru1_dataram_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru1_dataram_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.intc_base =\n        prussdrv.pru0_dataram_base + prussdrv.intc_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru0_control_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru0_control_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru0_debug_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru0_debug_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru1_control_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru1_control_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru1_debug_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru1_debug_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru0_iram_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru0_iram_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    prussdrv.pru1_iram_base =\n        prussdrv.pru0_dataram_base + prussdrv.pru1_iram_phy_base -\n        prussdrv.pru0_dataram_phy_base;\n    if (prussdrv.version == PRUSS_V2) {\n        prussdrv.pruss_sharedram_base =\n            prussdrv.pru0_dataram_base +\n            prussdrv.pruss_sharedram_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_cfg_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_cfg_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_uart_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_uart_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_iep_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_iep_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_ecap_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_ecap_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_miirt_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_miirt_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n        prussdrv.pruss_mdio_base =\n            prussdrv.pru0_dataram_base + prussdrv.pruss_mdio_phy_base -\n            prussdrv.pru0_dataram_phy_base;\n    }\n#ifndef DISABLE_L3RAM_SUPPORT\n    fd = open(PRUSS_UIO_DRV_L3RAM_BASE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.l3ram_phys_base =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n\n\n    fd = open(PRUSS_UIO_DRV_L3RAM_SIZE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.l3ram_map_size =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n\n    prussdrv.l3ram_base =\n        mmap(0, prussdrv.l3ram_map_size, PROT_READ | PROT_WRITE,\n             MAP_SHARED, prussdrv.mmap_fd, PRUSS_UIO_MAP_OFFSET_L3RAM);\n#endif\n\n    fd = open(PRUSS_UIO_DRV_EXTRAM_BASE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.extram_phys_base =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n\n    fd = open(PRUSS_UIO_DRV_EXTRAM_SIZE, O_RDONLY);\n    if (fd >= 0) {\n        read(fd, hexstring, PRUSS_UIO_PARAM_VAL_LEN);\n        prussdrv.extram_map_size =\n            strtoul(hexstring, NULL, HEXA_DECIMAL_BASE);\n        close(fd);\n    } else\n        return -1;\n\n\n    prussdrv.extram_base =\n        mmap(0, prussdrv.extram_map_size, PROT_READ | PROT_WRITE,\n             MAP_SHARED, prussdrv.mmap_fd, PRUSS_UIO_MAP_OFFSET_EXTRAM);\n\n    return 0;\n\n}\n\nint prussdrv_init(void)\n{\n    memset(&prussdrv, 0, sizeof(prussdrv));\n    return 0;\n\n}\n\nint prussdrv_open(unsigned int host_interrupt)\n{\n    char name[PRUSS_UIO_PRAM_PATH_LEN];\n    if (!prussdrv.fd[host_interrupt]) {\n        sprintf(name, \"/dev/uio%d\", host_interrupt);\n        prussdrv.fd[host_interrupt] = open(name, O_RDWR | O_SYNC);\n        return __prussdrv_memmap_init();\n    } else {\n        return -1;\n\n    }\n}\n\nint prussdrv_version() {\n    return prussdrv.version;\n}\n\nconst char * prussdrv_strversion(int version) {\n    switch (version) {\n        case PRUSS_V1:\n            return PRUSS_V1_STR;\n        case PRUSS_V2:\n            return PRUSS_V2_STR;\n        default:\n            return PRUSS_UNKNOWN_STR;\n    }\n}\n\nint prussdrv_pru_reset(unsigned int prunum)\n{\n    unsigned int *prucontrolregs;\n    if (prunum == 0)\n        prucontrolregs = (unsigned int *) prussdrv.pru0_control_base;\n    else if (prunum == 1)\n        prucontrolregs = (unsigned int *) prussdrv.pru1_control_base;\n    else\n        return -1;\n    *prucontrolregs = 0;\n    return 0;\n}\n\nint prussdrv_pru_enable(unsigned int prunum)\n{\n  return prussdrv_pru_enable_at(prunum, 0);\n}\n\nint prussdrv_pru_enable_at(unsigned int prunum, size_t addr)\n{\n    volatile uint32_t* prucontrolregs;\n    if (prunum == 0)\n        prucontrolregs = (volatile uint32_t *) prussdrv.pru0_control_base;\n    else if (prunum == 1)\n        prucontrolregs = (volatile uint32_t *) prussdrv.pru1_control_base;\n    else\n        return -1;\n\n    /* address is in bytes and must be converted in 32 bits words */\n    *prucontrolregs = ((uint32_t)(addr / sizeof(uint32_t)) << 16) | 2;\n\n    return 0;\n\n}\n\nint prussdrv_pru_disable(unsigned int prunum)\n{\n    unsigned int *prucontrolregs;\n    if (prunum == 0)\n        prucontrolregs = (unsigned int *) prussdrv.pru0_control_base;\n    else if (prunum == 1)\n        prucontrolregs = (unsigned int *) prussdrv.pru1_control_base;\n    else\n        return -1;\n    *prucontrolregs = 1;\n    return 0;\n\n}\n\nint prussdrv_pru_write_memory(unsigned int pru_ram_id,\n                              unsigned int wordoffset,\n                              const unsigned int *memarea,\n                              unsigned int bytelength)\n{\n    unsigned int *pruramarea, i, wordlength;\n    switch (pru_ram_id) {\n    case PRUSS0_PRU0_IRAM:\n        pruramarea = (unsigned int *) prussdrv.pru0_iram_base;\n        break;\n    case PRUSS0_PRU1_IRAM:\n        pruramarea = (unsigned int *) prussdrv.pru1_iram_base;\n        break;\n    case PRUSS0_PRU0_DATARAM:\n        pruramarea = (unsigned int *) prussdrv.pru0_dataram_base;\n        break;\n    case PRUSS0_PRU1_DATARAM:\n        pruramarea = (unsigned int *) prussdrv.pru1_dataram_base;\n        break;\n    case PRUSS0_SHARED_DATARAM:\n        if (prussdrv.version != PRUSS_V2)\n            return -1;\n        pruramarea = (unsigned int *) prussdrv.pruss_sharedram_base;\n        break;\n    default:\n        return -1;\n    }\n\n\n    wordlength = (bytelength + 3) >> 2; //Adjust length as multiple of 4 bytes\n    for (i = 0; i < wordlength; i++) {\n        *(pruramarea + i + wordoffset) = *(memarea + i);\n    }\n    return wordlength;\n\n}\n\n\nint prussdrv_pruintc_init(const tpruss_intc_initdata *prussintc_init_data)\n{\n    unsigned int *pruintc_io = (unsigned int *) prussdrv.intc_base;\n    unsigned int i, mask1, mask2;\n\n    pruintc_io[PRU_INTC_SIPR1_REG >> 2] = 0xFFFFFFFF;\n    pruintc_io[PRU_INTC_SIPR2_REG >> 2] = 0xFFFFFFFF;\n\n    for (i = 0; i < (NUM_PRU_SYS_EVTS + 3) >> 2; i++)\n        pruintc_io[(PRU_INTC_CMR1_REG >> 2) + i] = 0;\n    for (i = 0;\n         ((prussintc_init_data->sysevt_to_channel_map[i].sysevt != -1)\n          && (prussintc_init_data->sysevt_to_channel_map[i].channel !=\n              -1)); i++) {\n        __prussintc_set_cmr(pruintc_io,\n                            prussintc_init_data->sysevt_to_channel_map[i].\n                            sysevt,\n                            prussintc_init_data->sysevt_to_channel_map[i].\n                            channel);\n    }\n    for (i = 0; i < (NUM_PRU_HOSTS + 3) >> 2; i++)\n        pruintc_io[(PRU_INTC_HMR1_REG >> 2) + i] = 0;\n    for (i = 0;\n         ((prussintc_init_data->channel_to_host_map[i].channel != -1)\n          && (prussintc_init_data->channel_to_host_map[i].host != -1));\n         i++) {\n\n        __prussintc_set_hmr(pruintc_io,\n                            prussintc_init_data->channel_to_host_map[i].\n                            channel,\n                            prussintc_init_data->channel_to_host_map[i].\n                            host);\n    }\n\n    pruintc_io[PRU_INTC_SITR1_REG >> 2] = 0x0;\n    pruintc_io[PRU_INTC_SITR2_REG >> 2] = 0x0;\n\n\n    mask1 = mask2 = 0;\n    for (i = 0; prussintc_init_data->sysevts_enabled[i] != 255; i++) {\n        if (prussintc_init_data->sysevts_enabled[i] < 32) {\n            mask1 =\n                mask1 + (1 << (prussintc_init_data->sysevts_enabled[i]));\n        } else if (prussintc_init_data->sysevts_enabled[i] < 64) {\n            mask2 =\n                mask2 +\n                (1 << (prussintc_init_data->sysevts_enabled[i] - 32));\n        } else {\n            DEBUG_PRINTF(\"Error: SYS_EVT%d out of range\\n\",\n\t\t\t prussintc_init_data->sysevts_enabled[i]);\n            return -1;\n        }\n    }\n    pruintc_io[PRU_INTC_ESR1_REG >> 2] = mask1;\n    pruintc_io[PRU_INTC_SECR1_REG >> 2] = mask1;\n    pruintc_io[PRU_INTC_ESR2_REG >> 2] = mask2;\n    pruintc_io[PRU_INTC_SECR2_REG >> 2] = mask2;\n\n    for (i = 0; i < MAX_HOSTS_SUPPORTED; i++)\n        if (prussintc_init_data->host_enable_bitmask & (1 << i)) {\n            pruintc_io[PRU_INTC_HIEISR_REG >> 2] = i;\n        }\n\n    pruintc_io[PRU_INTC_GER_REG >> 2] = 0x1;\n\n    // Stash a copy of the intc settings\n    memcpy( &prussdrv.intc_data, prussintc_init_data,\n            sizeof(prussdrv.intc_data) );\n\n    return 0;\n}\n\nshort prussdrv_get_event_to_channel_map( unsigned int eventnum )\n{\n    unsigned int i;\n    for (i = 0; i < NUM_PRU_SYS_EVTS &&\n                prussdrv.intc_data.sysevt_to_channel_map[i].sysevt  !=-1 &&\n                prussdrv.intc_data.sysevt_to_channel_map[i].channel !=-1; ++i) {\n        if ( eventnum == prussdrv.intc_data.sysevt_to_channel_map[i].sysevt )\n            return prussdrv.intc_data.sysevt_to_channel_map[i].channel;\n    }\n    return -1;\n}\n\nshort prussdrv_get_channel_to_host_map( unsigned int channel )\n{\n    unsigned int i;\n    for (i = 0; i < NUM_PRU_CHANNELS &&\n                prussdrv.intc_data.channel_to_host_map[i].channel != -1 &&\n                prussdrv.intc_data.channel_to_host_map[i].host    != -1; ++i) {\n        if ( channel == prussdrv.intc_data.channel_to_host_map[i].channel )\n            /** -2 is because first two host interrupts are reserved\n             * for PRU0 and PRU1 */\n            return prussdrv.intc_data.channel_to_host_map[i].host - 2;\n    }\n    return -1;\n}\n\nshort prussdrv_get_event_to_host_map( unsigned int eventnum )\n{\n    short ans = prussdrv_get_event_to_channel_map( eventnum );\n    if (ans < 0) return ans;\n    return prussdrv_get_channel_to_host_map( ans );\n}\n\nint prussdrv_pru_send_event(unsigned int eventnum)\n{\n    unsigned int *pruintc_io = (unsigned int *) prussdrv.intc_base;\n    if (eventnum < 32)\n        pruintc_io[PRU_INTC_SRSR1_REG >> 2] = 1 << eventnum;\n    else\n        pruintc_io[PRU_INTC_SRSR2_REG >> 2] = 1 << (eventnum - 32);\n    return 0;\n}\n\nunsigned int prussdrv_pru_wait_event(unsigned int host_interrupt)\n{\n    unsigned int event_count;\n    read(prussdrv.fd[host_interrupt], &event_count, sizeof(int));\n    return event_count;\n}\n\nint prussdrv_pru_event_fd(unsigned int host_interrupt)\n{\n    if (host_interrupt < NUM_PRU_HOSTIRQS)\n        return prussdrv.fd[host_interrupt];\n    else\n        return -1;\n}\n\nint prussdrv_pru_clear_event(unsigned int host_interrupt, unsigned int sysevent)\n{\n    unsigned int *pruintc_io = (unsigned int *) prussdrv.intc_base;\n    if (sysevent < 32)\n        pruintc_io[PRU_INTC_SECR1_REG >> 2] = 1 << sysevent;\n    else\n        pruintc_io[PRU_INTC_SECR2_REG >> 2] = 1 << (sysevent - 32);\n\n    // Re-enable the host interrupt.  Note that we must do this _after_ the\n    // system event has been cleared so as to not re-tigger the interrupt line.\n    // See Section 6.4.9 of Reference manual about HIEISR register.\n    // The +2 is because the first two host interrupts are reserved for\n    // PRU0 and PRU1.\n    pruintc_io[PRU_INTC_HIEISR_REG >> 2] = host_interrupt+2;\n    return 0;\n}\n\nint prussdrv_pru_send_wait_clear_event(unsigned int send_eventnum,\n                                       unsigned int host_interrupt,\n                                       unsigned int ack_eventnum)\n{\n    prussdrv_pru_send_event(send_eventnum);\n    prussdrv_pru_wait_event(host_interrupt);\n    prussdrv_pru_clear_event(host_interrupt, ack_eventnum);\n    return 0;\n\n}\n\n\nint prussdrv_map_l3mem(void **address)\n{\n    *address = prussdrv.l3ram_base;\n    return 0;\n}\n\n\n\nint prussdrv_map_extmem(void **address)\n{\n\n    *address = prussdrv.extram_base;\n    return 0;\n\n}\n\nunsigned int prussdrv_extmem_size(void)\n{\n    return prussdrv.extram_map_size;\n}\n\nint prussdrv_map_prumem(unsigned int pru_ram_id, void **address)\n{\n    switch (pru_ram_id) {\n    case PRUSS0_PRU0_DATARAM:\n        *address = prussdrv.pru0_dataram_base;\n        break;\n    case PRUSS0_PRU1_DATARAM:\n        *address = prussdrv.pru1_dataram_base;\n        break;\n    case PRUSS0_SHARED_DATARAM:\n        if (prussdrv.version != PRUSS_V2)\n            return -1;\n        *address = prussdrv.pruss_sharedram_base;\n        break;\n    default:\n        *address = 0;\n        return -1;\n    }\n    return 0;\n}\n\nint prussdrv_map_peripheral_io(unsigned int per_id, void **address)\n{\n    if (prussdrv.version != PRUSS_V2)\n        return -1;\n\n    switch (per_id) {\n    case PRUSS0_CFG:\n        *address = prussdrv.pruss_cfg_base;\n        break;\n    case PRUSS0_UART:\n        *address = prussdrv.pruss_uart_base;\n        break;\n    case PRUSS0_IEP:\n        *address = prussdrv.pruss_iep_base;\n        break;\n    case PRUSS0_ECAP:\n        *address = prussdrv.pruss_ecap_base;\n        break;\n    case PRUSS0_MII_RT:\n        *address = prussdrv.pruss_miirt_base;\n        break;\n    case PRUSS0_MDIO:\n        *address = prussdrv.pruss_mdio_base;\n        break;\n    default:\n        *address = 0;\n        return -1;\n    }\n    return 0;\n}\n\nunsigned int prussdrv_get_phys_addr(const void *address)\n{\n    unsigned int retaddr = 0;\n    if ((address >= prussdrv.pru0_dataram_base)\n        && (address <\n            prussdrv.pru0_dataram_base + prussdrv.pruss_map_size)) {\n        retaddr =\n            ((unsigned int) (address - prussdrv.pru0_dataram_base) +\n             prussdrv.pru0_dataram_phy_base);\n    } else if ((address >= prussdrv.l3ram_base)\n               && (address <\n                   prussdrv.l3ram_base + prussdrv.l3ram_map_size)) {\n        retaddr =\n            ((unsigned int) (address - prussdrv.l3ram_base) +\n             prussdrv.l3ram_phys_base);\n    } else if ((address >= prussdrv.extram_base)\n               && (address <\n                   prussdrv.extram_base + prussdrv.extram_map_size)) {\n        retaddr =\n            ((unsigned int) (address - prussdrv.extram_base) +\n             prussdrv.extram_phys_base);\n    }\n    return retaddr;\n\n}\n\nvoid *prussdrv_get_virt_addr(unsigned int phyaddr)\n{\n    void *address = 0;\n    if ((phyaddr >= prussdrv.pru0_dataram_phy_base)\n        && (phyaddr <\n            prussdrv.pru0_dataram_phy_base + prussdrv.pruss_map_size)) {\n        address =\n            (void *) ((unsigned int) prussdrv.pru0_dataram_base +\n                      (phyaddr - prussdrv.pru0_dataram_phy_base));\n    } else if ((phyaddr >= prussdrv.l3ram_phys_base)\n               && (phyaddr <\n                   prussdrv.l3ram_phys_base + prussdrv.l3ram_map_size)) {\n        address =\n            (void *) ((unsigned int) prussdrv.l3ram_base +\n                      (phyaddr - prussdrv.l3ram_phys_base));\n    } else if ((phyaddr >= prussdrv.extram_phys_base)\n               && (phyaddr <\n                   prussdrv.extram_phys_base + prussdrv.extram_map_size)) {\n        address =\n            (void *) ((unsigned int) prussdrv.extram_base +\n                      (phyaddr - prussdrv.extram_phys_base));\n    }\n    return address;\n\n}\n\n\nint prussdrv_exit()\n{\n    int i;\n    munmap(prussdrv.pru0_dataram_base, prussdrv.pruss_map_size);\n    munmap(prussdrv.l3ram_base, prussdrv.l3ram_map_size);\n    munmap(prussdrv.extram_base, prussdrv.extram_map_size);\n    for (i = 0; i < NUM_PRU_HOSTIRQS; i++) {\n        if (prussdrv.fd[i])\n            close(prussdrv.fd[i]);\n    }\n    return 0;\n}\n\nint prussdrv_exec_program(int prunum, const char *filename)\n{\n  return prussdrv_exec_program_at(prunum, filename, 0);\n}\n\nint prussdrv_exec_program_at(int prunum, const char *filename, size_t addr)\n{\n    FILE *fPtr;\n    unsigned char fileDataArray[PRUSS_MAX_IRAM_SIZE];\n    int fileSize = 0;\n\n    // Open an File from the hard drive\n    fPtr = fopen(filename, \"rb\");\n    if (fPtr == NULL) {\n        DEBUG_PRINTF(\"File %s open failed\\n\", filename);\n\treturn -1;\n    } else {\n        DEBUG_PRINTF(\"File %s open passed\\n\", filename);\n    }\n    // Read file size\n    fseek(fPtr, 0, SEEK_END);\n    fileSize = ftell(fPtr);\n\n    if (fileSize == 0) {\n        DEBUG_PRINTF(\"File read failed.. Closing program\\n\");\n        fclose(fPtr);\n        return -1;\n    }\n\n    fseek(fPtr, 0, SEEK_SET);\n\n    if (fileSize !=\n        fread((unsigned char *) fileDataArray, 1, fileSize, fPtr)) {\n        DEBUG_PRINTF(\"WARNING: File Size mismatch\\n\");\n\tfclose(fPtr);\n\treturn -1;\n    }\n\n    fclose(fPtr);\n\n    return prussdrv_exec_code_at(prunum, (const unsigned int *) fileDataArray, fileSize, addr);\n}\n\nint prussdrv_exec_code(int prunum, const unsigned int *code, int codelen)\n{\n  return prussdrv_exec_code_at(prunum, code, codelen, 0);\n}\n\nint prussdrv_exec_code_at(int prunum, const unsigned int *code, int codelen, size_t addr)\n{\n    unsigned int pru_ram_id;\n\n    if (prunum == 0)\n        pru_ram_id = PRUSS0_PRU0_IRAM;\n    else if (prunum == 1)\n        pru_ram_id = PRUSS0_PRU1_IRAM;\n    else\n        return -1;\n\n    // Make sure PRU sub system is first disabled/reset\n    prussdrv_pru_disable(prunum);\n    prussdrv_pru_write_memory(pru_ram_id, 0, code, codelen);\n    prussdrv_pru_enable_at(prunum, addr);\n\n    return 0;\n}\n\nint prussdrv_load_datafile(int prunum, const char *filename)\n{\n    FILE *fPtr;\n    unsigned char fileDataArray[PRUSS_MAX_IRAM_SIZE];\n    int fileSize = 0;\n\n    // Open an File from the hard drive\n    fPtr = fopen(filename, \"rb\");\n    if (fPtr == NULL) {\n        DEBUG_PRINTF(\"File %s open failed\\n\", filename);\n\treturn -1;\n    } else {\n        DEBUG_PRINTF(\"File %s open passed\\n\", filename);\n    }\n    // Read file size\n    fseek(fPtr, 0, SEEK_END);\n    fileSize = ftell(fPtr);\n\n    if (fileSize == 0) {\n        DEBUG_PRINTF(\"File read failed.. Closing program\\n\");\n        fclose(fPtr);\n        return -1;\n    }\n\n    fseek(fPtr, 0, SEEK_SET);\n\n    if (fileSize !=\n        fread((unsigned char *) fileDataArray, 1, fileSize, fPtr)) {\n        DEBUG_PRINTF(\"WARNING: File Size mismatch\\n\");\n\tfclose(fPtr);\n\treturn -1;\n    }\n\n    fclose(fPtr);\n\n    return prussdrv_load_data(prunum, (const unsigned int *) fileDataArray, fileSize);\n}\n\nint prussdrv_load_data(int prunum, const unsigned int *code, int codelen)\n{\n    unsigned int pru_ram_id;\n\n    if (prunum == 0)\n        pru_ram_id = PRUSS0_PRU0_DATARAM;\n    else if (prunum == 1)\n        pru_ram_id = PRUSS0_PRU1_DATARAM;\n    else\n        return -1;\n\n    // Make sure PRU sub system is first disabled/reset\n    prussdrv_pru_disable(prunum);\n    prussdrv_pru_write_memory(pru_ram_id, 0, code, codelen);\n    //prussdrv_pru_enable(prunum);\n\n    return 0;\n}\n","undoManager":{"mark":6,"position":-1,"stack":[[{"start":{"row":675,"column":12},"end":{"row":675,"column":13},"action":"insert","lines":["e"],"id":8}],[{"start":{"row":675,"column":11},"end":{"row":675,"column":12},"action":"insert","lines":["t"],"id":8}],[{"start":{"row":675,"column":10},"end":{"row":675,"column":11},"action":"insert","lines":["u"],"id":9}],[{"start":{"row":675,"column":9},"end":{"row":675,"column":10},"action":"insert","lines":["c"],"id":10}],[{"start":{"row":675,"column":8},"end":{"row":675,"column":9},"action":"insert","lines":["e"],"id":11}],[{"start":{"row":675,"column":7},"end":{"row":675,"column":8},"action":"insert","lines":["x"],"id":12}],[{"start":{"row":675,"column":6},"end":{"row":675,"column":36},"action":"remove","lines":[" Open an File from the hard dr"],"id":13},{"start":{"row":675,"column":6},"end":{"row":675,"column":7},"action":"insert","lines":["e"]}]]},"ace":{"folds":[],"scrolltop":10369,"scrollleft":0,"selection":{"start":{"row":704,"column":64},"end":{"row":704,"column":64},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":690,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1436725452000}