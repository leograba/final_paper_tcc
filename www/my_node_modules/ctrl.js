'use strict';

var debug = require('debug')('ctrl');
var fs = require('fs');
var b = require('octalbonescript');
var gpioCfg = require('./gpio_cfg.js');
var log = require('./log_check_misc.js');

module.exports.startMashingProcess = function (recipe, res, lockFile, recipesPath, callback){
	/*Starts the mashing process, checking if everything is in order, starting
	the temperature logging and the heating of the mash water.
	The callback function is passed as callback to the heatMashWater function*/
	var serverResponse = {resp:"success"};
	var recipeContents ;
	if(global.environmentVariables.okToStart){//first check is if the recipe is ok to start
		if(recipe == global.environmentVariables.recipe){//recipe name should match also
			fs.writeFile(lockFile, 1, function(err){//write to lockfile telling there is a recipe in progress
				if(err){
					serverResponse.resp = "could not write to lockfile";
					res.send(serverResponse);
					callback(serverResponse.resp,null);
					return;
				}
				log.logToFile("production starting", 1);//log to file
				fs.readFile(recipesPath + "/" + global.environmentVariables.recipe, function(err, data){
					if(err){//if file contents could not be retrieved
						serverResponse.resp = "couldn't read recipe file";//tells the client
						res.send(serverResponse);
						callback(serverResponse.resp,null);
						return;
					}//if file was successfully read
					log.startTemperatureLogging();
					recipeContents = data.toString("UTF8").split("\n");//split contents to array
					for(var i = 0; i < recipeContents.length; i++){//get only the relevant data
						recipeContents[i] = recipeContents[i].split('"')[1];
					}
					serverResponse.resp = "success";//tells the client everything went alright
					res.send(serverResponse);
					heatMashWater(recipeContents);//start to heat the mash water
					//The callback is called when the heat starts, not after it finishes
					callback(null,"Started to heat mash water");
				});
			});
		}
		else{//if recipe name doesn't match the one from "startRequest"
			serverResponse.resp = "failed";
			res.send(serverResponse);
			callback(serverResponse.resp,null);
		}
	}
	else{//if recipe isn't ok to start
		serverResponse.resp = "failed";
		res.send(serverResponse);
		callback(serverResponse.resp,null);
	}
};

function heatMashWater(recipeContents){
	//heats the mashing water to the starting setpoint
	var mashSetpoint = recipeContents[7];
	var instantPath = "./datalog/instant.csv";
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var reachedSetpoint = false;//var set to true the first time the checkpoint is reached
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	global.heatingPower = 2;
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	gpioCfg.changeStatusIO("mash_pump", "true");//turn the recirculation pump on
	log.logToFile("heating mash water", 2, "startHeating");//log to file, first time get notable timestamp
	var logTimer = setInterval(function(){//logs the heating process every ~5s
		log.logToFile("heating mash water", 2);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function(){//read temperature every second
		debug("Executing temperature control loop[1]");
		log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){
			if(err){
				debug("something went wrong");
				return;
			}
			updateHeatingConditions("MT", mashSetpoint, temperature, function(){
				if(!reachedSetpoint){//if it is the first time the setpoint is reached
					debug('Heating of the mash water finished. Now the user must add the grains.');
					debug(	"            Current temperature = " + temperature + "\n"
							+ "            Reading errors = " + logReadHandler.errorCount);
					reachedSetpoint = true;//holds this information
					clearInterval(logTimer);//stop the logging
					log.logToFile("waiting for grains", 3, "finishHeating");//log to file at least once
					logTimer = setInterval(function(){//logs that system is waiting for user input
						log.logToFile("waiting for grains", 3);//log to file
					}, 5000);
				}
				//while the temperature is above the setpoint, do nothing - just wait for the user
			});
		});
		//this if must be outside the updateHeatingConditions() call, otherwise recursive behavior mess it up
		if(global.environmentVariables.readyForNextStep){//wait for the temperature reach setpoint and user add grains
			global.environmentVariables.readyForNextStep = false;//prepare the flag for the next step request
			clearInterval(logTimer);//stop the "waiting for grains" logging
			clearInterval(readTmpTimer);//stop the temperature adjusting loop
			rampControl(recipeContents);
		}
	},1000);
	//just do the next things after the user added the grains
}

function rampControl(recipeContents){
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var instantPath = "./datalog/instant.csv";
	var instantBK = "./datalog/instant_bk.csv";
	var currentSetpointPointer = 1;
	var finishedRamp = false;
	var mashSetpoint = recipeContents[8];//get the first setpoint
	var spargeSetpoint = recipeContents[5];
	var spargeSet = false;// only set this if the sparge temperature is set
	var stepTime = 60*1000*recipeContents[9];//get the first step rest time in ms
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	global.environmentVariables.tmpBKsetp = spargeSetpoint;
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	var logReadHandlerBK = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	var d = new Date();
	//var  = d.getTime();
	if(spargeSetpoint){//if there is a sparge temperature
		spargeSet = true;//then assumes there will be sparging water to heat
	}
	fs.writeFile(lockFile, 0, function(err){//release system to start new production (for testing purpose only)
		if(err) return;
	});
	debug("Ramp control started!");
	log.logToFile("mash ramp in progress", 4, "sRamp0");//log immediately and hold notable timestamp
	var logTimer = setInterval(function(){//logs that the mash ramp is in progress
		log.logToFile("mash ramp[" + currentSetpointPointer + "] in progress", 4);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function (){//read temperature every second
		debug("Executing temperature control loop[2]");
		if(global.environmentVariables.readyForNextStep && currentSetpointPointer < 8){//if there are still mashing steps
			debug("setpoint pointer: " + currentSetpointPointer);//cannot enter here when currentSetpointPointer == 1
			global.environmentVariables.readyForNextStep = false;//wait for the step to finish before checking next step
			if(recipeContents[8 + 2*currentSetpointPointer]){//and the value is not empty
				mashSetpoint = recipeContents[8 + 2*currentSetpointPointer];//get the new setpoint
				stepTime = 60*1000*recipeContents[9 + 2*currentSetpointPointer];//get the next step rest time in ms
				global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
				debug("Starting next ramp");
				clearInterval(logTimer);//stop logging step to log ramp
				log.logToFile("mash ramp in progress", 4, "sRamp" + currentSetpointPointer);//log immediately and hold notable timestamp
				logTimer = setInterval(function(){//logs that the mash ramp is in progress
					log.logToFile("mash ramp[" + currentSetpointPointer + "] in progress", 4);//log to file
				}, 5000);
			}
			else{
				//gets here for all the lasting setpoints (currentSetpointPointer <= 7)
				global.environmentVariables.readyForNextStep = true;//ready for the sparging/boil
				debug("End of the mash ramps/steps process " + currentSetpointPointer);
			}
			currentSetpointPointer++;//increment to point to the next setpoint
		}
		else if(global.environmentVariables.readyForNextStep){//start the next step, which is sparging or boil
			gpioCfg.changeStatusIO("mash_heat", "false");//just to make sure, turn off heating elements
			gpioCfg.changeStatusIO("boil_heat", "false");//just to make sure, turn off heating elements
			gpioCfg.changeStatusIO("mash_pump", "false");//also shutdown the recirculation pump
			log.stopTemperatureLogging();//for testing purposes
			clearInterval(readTmpTimer);//stop everything, for now at least
			clearInterval(logTimer);
			if(spargeSet){//if there will be sparging, then start it
				spargingControl();//start the sparging process
			}
			else{//goes straight to the boil, without sparging
				debug("No sparging: starting the boil process.");
			}
		}
		else{//temperature control code, no need to execute when it is getting the next setpoint
			log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){//read current temperature
				if(err){
					debug("something went wrong");
					return;
				}
				updateHeatingConditions("MT", mashSetpoint, temperature, function(){//control temperature for current setpoint
					if(!finishedRamp){//if the ramp just reached its setpoint
						//log and save the notable timestamp fRamp
						finishedRamp = true;
						clearInterval(logTimer);//stop logging ramp to log step
						log.logToFile("mash step[" + currentSetpointPointer + "] in progress", 5, "fRamp" + currentSetpointPointer);
						logTimer = setInterval(function(){//logs that the mash ramp is in progress
							log.logToFile("mash step[" + currentSetpointPointer + "] in progress", 5);//log to file
						}, 5000);
						debug('Ramp finished, keeping temperature for the duration of the step.');
						debug(	"            Current temperature = " + temperature + "\n"
								+ "            Reading errors = " + logReadHandler.errorCount);
					}
					if((global.environmentVariables.timestamps.curr - global.environmentVariables.timestamps["fRamp" + currentSetpointPointer]) > stepTime){
						//if the step rest is finished
						finishedRamp = false;
						global.environmentVariables.readyForNextStep = true;//if setpoint is reached
						debug('Step finished, starting next ramp or going to sparging.');
						debug(	"            Current temperature = " + temperature + "\n"
								+ "            Reading errors = " + logReadHandler.errorCount);
					}
					else{//if it is in the middle of a step, heat the sparging water and tell the user the step time left
						global.environmentVariables.timeLeft = //in minutes (not round) = total time - elapsed time
						(stepTime - (global.environmentVariables.timestamps.curr - global.environmentVariables.timestamps["fRamp" + currentSetpointPointer]))/60000;
						if(spargeSet){//only heat sparging water if there is sparging water to heat
							log.getTemperatureReading(instantBK, logReadHandlerBK, function(err, temperature){//read current temperature
								if(err){
									debug("something went wrong");
									return;
								}
								updateHeatingConditions("BK", spargeSetpoint, temperature, function(){//heat the sparging water
								});
							});
						}
					}
				});
			});
		}
	},1000);
}

function spargingControl(){
	debug("Starting the sparging process.");
}

function updateHeatingConditions(vessel, setp, temperature, callback){
	//This function must be called in a loop, every loop interation
	if(vessel == "mash_heat" || vessel == "MT" || vessel == "mash tun"){
		vessel = "mash_heat";//if wants to heat the mash tun
		global.environmentVariables.tmpMT = temperature;//update the mash tun temperature
		if(global.environmentVariables.ioStatus["boil_heat"].state == b.HIGH){//security check
			gpioCfg.changeStatusIO("boil_heat", "false");//turn off the other heating element
			debug("Security shutdown of the BK heater");
		}
	}
	else if(vessel == "boil_heat" || vessel == "BK" || vessel == "brewing kettle" || vessel == "copper"){
		vessel = "boil_heat";//if wants to heat the brewing kettle
		global.environmentVariables.tmpBK = temperature;//update the brewing kettle temperature
		if(global.environmentVariables.ioStatus["mash_heat"].state == b.HIGH){//security check
			gpioCfg.changeStatusIO("mash_heat", "false");//turn off the other heating element
			debug("Security shutdown of the MT heater");
		}
	}
	else{//if vessel is unknown
		callback("unknown vessel");
		return;//don't even try to heat
	}
	debug("Heating power variable: " + global.heatingPower);
	if(temperature < 0.7*setp){//if temperature is less then 0.7 of the setpoint
		debug(vessel + ": 100% heating power");
		gpioCfg.changeStatusIO(vessel, "true");//give 100% power to the heating resistor
	}
	else if(temperature < 0.9*setp){//if temperature between 0.7 and 0.9 of the setpoint 
		debug(vessel + ": 66% heating power");
		if(global.heatingPower == 0){//give 66% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "false");// 1/3 of the time off
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "true");// 2/3 of the time on
			global.heatingPower--;
		}
	}
	else if(temperature < setp){//if temperature between 0.9 and 1.0 of the setpoint 
		debug(vessel + ": 33% heating power");
		if(global.heatingPower == 0){//give 33% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "true");// 1/3 of the time on
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "false");// 2/3 of the time off
			global.heatingPower--;
		}
	}
	else{//in this case, the temperature got to the setpoint
		debug(vessel + ": 0% heating power");
		gpioCfg.changeStatusIO(vessel, "false");// turn the heating element off
		callback(null);//choose what to do
	}
}