'use strict';

var debug = require('debug')('ctrl');
var fs = require('fs');
var gpioCfg = require('./gpio_cfg.js');
var log = require('./log_check_misc.js');

module.exports.startMashingProcess = function (recipe, res, lockFile, recipesPath, callback){
	/*Starts the mashing process, checking if everything is in order, starting
	the temperature logging and the heating of the mash water.
	The callback function is passed as callback to the heatMashWater function*/
	var serverResponse = {resp:"success"};
	var recipeContents ;
	if(global.environmentVariables.okToStart){//first check is if the recipe is ok to start
		if(recipe == global.environmentVariables.recipe){//recipe name should match also
			fs.writeFile(lockFile, 1, function(err){//write to lockfile telling there is a recipe in progress
				if(err){
					serverResponse.resp = "could not write to lockfile";
					res.send(serverResponse);
					callback(serverResponse.resp,null);
					return;
				}
				log.logToFile("production starting", 1);//log to file
				fs.readFile(recipesPath + "/" + global.environmentVariables.recipe, function(err, data){
					if(err){//if file contents could not be retrieved
						serverResponse.resp = "couldn't read recipe file";//tells the client
						res.send(serverResponse);
						callback(serverResponse.resp,null);
						return;
					}//if file was successfully read
					log.startTemperatureLogging();
					recipeContents = data.toString("UTF8").split("\n");//split contents to array
					for(var i = 0; i < recipeContents.length; i++){//get only the relevant data
						recipeContents[i] = recipeContents[i].split('"')[1];
					}
					serverResponse.resp = "success";//tells the client everything went alright
					res.send(serverResponse);
					heatMashWater(recipeContents);//start to heat the mash water
					//The callback is called when the heat starts, not after it finishes
					callback(null,"Started to heat mash water.");
				});
			});
		}
		else{//if recipe name doesn't match the one from "startRequest"
			serverResponse.resp = "failed";
			res.send(serverResponse);
			callback(serverResponse.resp,null);
		}
	}
	else{//if recipe isn't ok to start
		serverResponse.resp = "failed";
		res.send(serverResponse);
		callback(serverResponse.resp,null);
	}
};

function heatMashWater(recipeContents){
	//heats the mashing water to the starting setpoint
	var mashSetpoint = recipeContents[7];
	var spargeSetpoint = recipeContents[5];
	var instantPath = "./datalog/instant.csv";
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var reachedSetpoint = false;//var set to true the first time the checkpoint is reached
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	global.heatingPower = 2;
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	global.environmentVariables.tmpBKsetp = spargeSetpoint;
	gpioCfg.changeStatusIO("mash_pump", "true");//turn the recirculation pump on
	
	var logTimer = setInterval(function(){//logs the heating process every ~5s
		log.logToFile("heating mash water", 2);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function(){//read temperature every second
		debug("Executing temperature control loop[1]");
		log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){
			if(err){
				debug("something went wrong");
				return;
			}
			updateHeatingConditions("MT", mashSetpoint, temperature, function(){
				if(!reachedSetpoint){//if it is the first time the setpoint is reached
					debug('Heating of the mash water finished. Now the user must add the grains.');
					debug(	"            Current temperature = " + temperature + "\n"
							+ "            Reading errors = " + logReadHandler.errorCount);
					reachedSetpoint = true;//holds this information
					clearInterval(logTimer);//stop the logging
					log.logToFile("waiting for grains", 3);//log to file at least once
					logTimer = setInterval(function(){//logs that system is waiting for user input
						log.logToFile("waiting for grains", 3);//log to file
					}, 5000);
				}
				//while the temperature is above the setpoint, do nothing - just wait for the user
			});
		});
		//this if must be outside the updateHeatingConditions() call, otherwise recursive behavior mess it up
		if(global.environmentVariables.readyForNextStep){//wait for the temperature reach setpoint and user add grains
			global.environmentVariables.readyForNextStep = false;//prepare the flag for the next step request
			clearInterval(logTimer);//stop the "waiting for grains" logging
			clearInterval(readTmpTimer);//stop the temperature adjusting loop
			rampControl(recipeContents);
		}
	},1000);
	//just do the next things after the user added the grains
}

function rampControl(recipeContents){
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var instantPath = "./datalog/instant.csv";
	var currentSetpointPointer = 8;
	var mashSetpoint = recipeContents[currentSetpointPointer];//get the first setpoint;
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	var reachedSetpoint = false;//var set to true the first time the checkpoint is reached
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	var d = new Date();
	//var  = d.getTime();
	fs.writeFile(lockFile, 0, function(err){//release system to start new production (for testing purpose only)
		if(err) return;
	});
	debug("Ramp control started!");
	log.logToFile("mash ramp in progress", 4);//log immediately
	var logTimer = setInterval(function(){//logs that the mash ramp is in progress
		log.logToFile("mash ramp in progress", 4);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function (){//read temperature every second
		debug("Executing temperature control loop[2]");
		if(global.environmentVariables.readyForNextStep && currentSetpointPointer <= 22){//if there are still mashing steps
			if(recipeContents[currentSetpointPointer]){//and the value is not empty
				mashSetpoint = recipeContents[currentSetpointPointer];//get the new setpoint
				global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
				debug("Starting next ramp");
			}
			else{
				//assumes all the next recipe values will also be empty and finish the whole thing
				debug("End of the mash ramps/steps process");
				clearInterval(readTmpTimer);//stop everything, for now at least
				clearInterval(logTimer);
				gpioCfg.changeStatusIO("mash_heat", "false");//just to make sure, turn off heating element
				gpioCfg.changeStatusIO("mash_pump", "false");//also shutdown the recirculation pump
				//spargingControl();//start the sparging process
			}
			currentSetpointPointer += 2;//if increment only, would read time
			global.environmentVariables.readyForNextStep = false;//wait for the step to finish before checking next step
		}
		else{//no need to execute this code when it is getting the next setpoint
			log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){//read current temperature
				if(err){
					debug("something went wrong");
					return;
				}
				updateHeatingConditions("MT", mashSetpoint, temperature, function(){//control temperature for current setpoint
					global.environmentVariables.readyForNextStep = true;//if setpoint is reached
					//before setting this variable, should wait for the step time
					debug('Ramp finished, keeping temperature for the duration of the step.');
					debug(	"            Current temperature = " + temperature + "\n"
							+ "            Reading errors = " + logReadHandler.errorCount);
				});
			});
		}
	},1000);
}

function updateHeatingConditions(vessel, setp, temperature, callback){
	//This function must be called in a loop, every loop interation
	if(vessel == "mash_heat" || vessel == "MT" || vessel == "mash tun"){
		vessel = "mash_heat";//if wants to heat the mash tun
	}
	else if(vessel == "boil_heat" || vessel == "BK" || vessel == "brewing kettle" || vessel == "copper"){
		vessel = "boil_heat";//if wants to heat the brewing kettle
	}
	else{//if vessel is unknown
		callback("unknown vessel");
		return;//don't even try to heat
	}
	debug("Heating power variable: " + global.heatingPower);
	global.environmentVariables.tmpMT = temperature;//update the mash tun temperature
	if(temperature < 0.7*setp){//if temperature is less then 0.7 of the setpoint
		debug("100% heating power");
		gpioCfg.changeStatusIO(vessel, "true");//give 100% power to the heating resistor
	}
	else if(temperature < 0.9*setp){//if temperature between 0.7 and 0.9 of the setpoint 
		debug("66% heating power");
		if(global.heatingPower == 0){//give 66% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "false");// 1/3 of the time off
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "true");// 2/3 of the time on
			global.heatingPower--;
		}
	}
	else if(temperature < setp){//if temperature between 0.9 and 1.0 of the setpoint 
		debug("33% heating power");
		if(global.heatingPower == 0){//give 33% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "true");// 1/3 of the time on
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "false");// 2/3 of the time off
			global.heatingPower--;
		}
	}
	else{//in this case, the temperature got to the setpoint
		debug("0% heating power");
		gpioCfg.changeStatusIO(vessel, "false");// turn the heating element off
		callback(null);//choose what to do
	}
}