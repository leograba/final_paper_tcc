'use strict';

var debug = require('debug')('ctrl');
var fs = require('fs');
var b = require('octalbonescript');
var gpioCfg = require('./gpio_cfg.js');
var log = require('./log_check_misc.js');

module.exports.startMashingProcess = function (recipe, res, lockFile, recipesPath, callback){
	/*Starts the mashing process, checking if everything is in order, starting
	the temperature logging and the heating of the mash water.
	The callback function is passed as callback to the heatMashWater function*/
	var serverResponse = {resp:"success"};
	var recipeContents ;
	if(global.environmentVariables.okToStart){//first check is if the recipe is ok to start
		if(recipe == global.environmentVariables.recipe){//recipe name should match also
			fs.writeFile(lockFile, 1, function(err){//write to lockfile telling there is a recipe in progress
				if(err){
					serverResponse.resp = "could not write to lockfile";
					res.send(serverResponse);
					callback(serverResponse.resp,null);
					return;
				}
				log.logToFile("production starting", 1);//log to file
				fs.readFile(recipesPath + "/" + global.environmentVariables.recipe, function(err, data){
					if(err){//if file contents could not be retrieved
						serverResponse.resp = "couldn't read recipe file";//tells the client
						res.send(serverResponse);
						callback(serverResponse.resp,null);
						return;
					}//if file was successfully read
					log.startTemperatureLogging();
					recipeContents = data.toString("UTF8").split("\n");//split contents to array
					for(var i = 0; i < recipeContents.length; i++){//get only the relevant data
						recipeContents[i] = recipeContents[i].split('"')[1];
					}
					serverResponse.resp = "success";//tells the client everything went alright
					res.send(serverResponse);
					heatMashWater(recipeContents);//start to heat the mash water
					//The callback is called when the heat starts, not after it finishes
					callback(null,"Started to heat mash water");
				});
			});
		}
		else{//if recipe name doesn't match the one from "startRequest"
			serverResponse.resp = "failed";
			res.send(serverResponse);
			callback(serverResponse.resp,null);
		}
	}
	else{//if recipe isn't ok to start
		serverResponse.resp = "failed";
		res.send(serverResponse);
		callback(serverResponse.resp,null);
	}
};

function heatMashWater(recipeContents){
	//heats the mashing water to the starting setpoint
	var mashSetpoint = recipeContents[7];
	var instantPath = "./datalog/instant.csv";
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var reachedSetpoint = false;//var set to true the first time the checkpoint is reached
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	global.heatingPower = 2;
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	gpioCfg.changeStatusIO("mash_pump", "true");//turn the recirculation pump on
	log.logToFile("heating mash water", 2, "startHeating");//log to file, first time get notable timestamp
	var logTimer = setInterval(function(){//logs the heating process every ~5s
		log.logToFile("heating mash water", 2);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function(){//read temperature every second
		debug("Executing temperature control loop[1]");
		log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){
			if(err){
				debug("something went wrong");
				return;
			}
			updateHeatingConditions("MT", mashSetpoint, temperature, function(){
				if(!reachedSetpoint){//if it is the first time the setpoint is reached
					debug('Heating of the mash water finished. Now the user must add the grains.');
					debug(	"            Current temperature = " + temperature + "\n"
							+ "            Reading errors = " + logReadHandler.errorCount);
					reachedSetpoint = true;//holds this information
					clearInterval(logTimer);//stop the logging
					log.logToFile("waiting for grains", 3, "finishHeating");//log to file at least once
					logTimer = setInterval(function(){//logs that system is waiting for user input
						log.logToFile("waiting for grains", 3);//log to file
					}, 5000);
				}
				//while the temperature is above the setpoint, do nothing - just wait for the user
			});
		});
		//this if must be outside the updateHeatingConditions() call, otherwise recursive behavior mess it up
		if(global.environmentVariables.readyForNextStep){//wait for the temperature reach setpoint and user add grains
			global.environmentVariables.readyForNextStep = false;//prepare the flag for the next step request
			clearInterval(logTimer);//stop the "waiting for grains" logging
			clearInterval(readTmpTimer);//stop the temperature adjusting loop
			rampControl(recipeContents);
		}
	},1000);
	//just do the next things after the user added the grains
}

function rampControl(recipeContents){
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var instantPath = "./datalog/instant.csv";
	var instantBK = "./datalog/instant_bk.csv";
	var currentSetpointPointer = 1;
	var finishedRamp = false;
	var mashSetpoint = recipeContents[8];//get the first setpoint
	var spargeSetpoint = recipeContents[5];
	var spargeSet = false;// only set this if the sparge temperature is set
	var stepTime = 60*1000*recipeContents[9];//get the first step rest time in ms
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	global.environmentVariables.tmpBKsetp = spargeSetpoint;
	var logReadHandler = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	var logReadHandlerBK = {
		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
		errorCount: 0//counts the file reading errors
	};
	if(spargeSetpoint){//if there is a sparge temperature
		spargeSet = true;//then assumes there will be sparging water to heat
	}
	fs.writeFile(lockFile, 0, function(err){//release system to start new production (for testing purpose only)
		if(err) return;
	});
	debug("Ramp control started!");
	log.logToFile("mash ramp in progress", 4, "sRamp0");//log immediately and hold notable timestamp
	var logTimer = setInterval(function(){//logs that the mash ramp is in progress
		log.logToFile("mash ramp[" + currentSetpointPointer + "] in progress", 4);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function (){//read temperature every second
		debug("Executing temperature control loop[2]");
		if(global.environmentVariables.readyForNextStep && currentSetpointPointer < 8){//if there are still mashing steps
			debug("setpoint pointer: " + currentSetpointPointer);//cannot enter here when currentSetpointPointer == 1
			global.environmentVariables.readyForNextStep = false;//wait for the step to finish before checking next step
			if(recipeContents[8 + 2*currentSetpointPointer]){//and the value is not empty
				mashSetpoint = recipeContents[8 + 2*currentSetpointPointer];//get the new setpoint
				stepTime = 60*1000*recipeContents[9 + 2*currentSetpointPointer];//get the next step rest time in ms
				global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
				debug("Starting next ramp");
				clearInterval(logTimer);//stop logging step to log ramp
				log.logToFile("mash ramp in progress", 4, "sRamp" + currentSetpointPointer);//log immediately and hold notable timestamp
				logTimer = setInterval(function(){//logs that the mash ramp is in progress
					log.logToFile("mash ramp[" + currentSetpointPointer + "] in progress", 4);//log to file
				}, 5000);
			}
			else{
				//gets here for all the lasting setpoints (currentSetpointPointer <= 7)
				global.environmentVariables.readyForNextStep = true;//ready for the sparging/boil
				debug("End of the mash ramps/steps process " + currentSetpointPointer);
			}
			currentSetpointPointer++;//increment to point to the next setpoint
		}
		else if(global.environmentVariables.readyForNextStep){//start the next step, which is sparging or boil
			gpioCfg.changeStatusIO("mash_heat", "false");//just to make sure, turn off heating elements
			gpioCfg.changeStatusIO("boil_heat", "false");//just to make sure, turn off heating elements
			gpioCfg.changeStatusIO("mash_pump", "false");//also shutdown the recirculation pump
			log.stopTemperatureLogging();//for testing purposes
			clearInterval(readTmpTimer);//stop everything, for now at least
			clearInterval(logTimer);
			if(spargeSet){//if there will be sparging, then start it
				spargingControl(recipeContents);//start the sparging process
			}
			else{//goes straight to the boil, without sparging
				debug("No sparging: starting the boil process.");
			}
		}
		else{//temperature control code, no need to execute when it is getting the next setpoint
			log.getTemperatureReading(instantPath, logReadHandler, function(err, temperature){//read current temperature
				if(err){
					debug("something went wrong");
					return;
				}
				updateHeatingConditions("MT", mashSetpoint, temperature, function(){//control temperature for current setpoint
					if(!finishedRamp){//if the ramp just reached its setpoint
						//log and save the notable timestamp fRamp
						finishedRamp = true;
						clearInterval(logTimer);//stop logging ramp to log step
						log.logToFile("mash step[" + currentSetpointPointer + "] in progress", 5, "fRamp" + currentSetpointPointer);
						logTimer = setInterval(function(){//logs that the mash ramp is in progress
							log.logToFile("mash step[" + currentSetpointPointer + "] in progress", 5);//log to file
						}, 5000);
						debug('Ramp finished, keeping temperature for the duration of the step.');
						debug(	"            Current temperature = " + temperature + "\n"
								+ "            Reading errors = " + logReadHandler.errorCount);
					}
					if((global.environmentVariables.timestamps.curr - global.environmentVariables.timestamps["fRamp" + currentSetpointPointer]) > stepTime){
						//if the step rest is finished
						finishedRamp = false;
						global.environmentVariables.readyForNextStep = true;//if setpoint is reached
						debug('Step finished, starting next ramp or going to sparging.');
						debug(	"            Current temperature = " + temperature + "\n"
								+ "            Reading errors = " + logReadHandler.errorCount);
					}
					else{//if it is in the middle of a step, heat the sparging water and tell the user the step time left
						global.environmentVariables.timeLeft = //in minutes (not round) = total time - elapsed time
						(stepTime - (global.environmentVariables.timestamps.curr - global.environmentVariables.timestamps["fRamp" + currentSetpointPointer]))/60000;
						if(spargeSet){//only heat sparging water if there is sparging water to heat
							log.getTemperatureReading(instantBK, logReadHandlerBK, function(err, temperature){//read current temperature
								if(err){
									debug("something went wrong");
									return;
								}
								updateHeatingConditions("BK", spargeSetpoint, temperature, function(){//heat the sparging water
								});
							});
						}
					}
				});
			});
		}
	},1000);
}

function spargingControl(recipeContents){
	//function heavily based in timing. The time it takes for the water to flow is pretty predictable.
	//The time for the mash to drain depends on the recipe, hence the mash tun overflow watching device.
	//Because the pump flow is higher then the drain flow, the pump must be controlled to adjust.
	//The pump must start some time after the drain, so the grain bed is almost uncovered by the mash.
	//Also, in case of overflow, there must be a predefined time or time function to wait until the recirculation restarts.
	var mashTunOverflow = false;
	var finishedFirstDrain = false;//should modify to use setTimeout instead of setInterval
	var finishedSpargeTime = false;//should modify to use setTimeout instead of setInterval
	//the time setpoints are based on the volume of water used in mashing and sparging
	var drainTimeSetp = 500*recipeContents[3];//time in ms that should wait before showering with sparge water
	var spargeTimeSetp = 3000*recipeContents[4];//time in ms that should wait before finishing the process
	var overflowTimeSetp = 30000;//time to wait before pumping the sparge water again
	var realSpargeTime = 0;//approximately the time that the recirculation pump is working in ms
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var d = new Date();
	debug("Starting the sparging process");
	log.logToFile("sparging in progress", 6, "startDrain");//logs the notable startDrain timestamp
	gpioCfg.changeStatusIO("mash_valve", "true");//open the drain valve
	var spargeTimer = setInterval(function(){//handles the sparging process
		//Maybe there is no need to get current time, since all the logging inside this loop does it approximately
		//global.environmentVariables.timestamps.curr = d.getTime();//get current time
		if(!finishedFirstDrain && !mashTunOverflow && (global.environmentVariables.timestamps.curr - global.environmentVariables.timestamps.startDrain) > drainTimeSetp){
			//if it is time to start spraying the sparge water, and there is no overflow
			finishedFirstDrain = true;//cannot enter this conditional again
			debug("Finished the first drain");
			gpioCfg.changeStatusIO("boil_valve", "true");//open the recirculation valve
			gpioCfg.changeStatusIO("boil_pump", "true");//get the pump to run, consider some method do control the flow rate
			log.logToFile("sparging in progress", 6, "startSparge");//logs the notable startSparge timestamp
		}
		else if(finishedFirstDrain && !mashTunOverflow){//if it is running nicely for sure and the fisrt drain is completed
			realSpargeTime += 500;//add approximately the loop time
			log.logToFile("sparging in progress", 6);//log to file
			if(realSpargeTime > spargeTimeSetp && !finishedSpargeTime){//if the running time is enough
				finishedSpargeTime = true;
				debug("Stopping the sparging process. Waiting for the mash to completely drain")
				gpioCfg.changeStatusIO("boil_valve", "false");//close the recirculation valve
				gpioCfg.changeStatusIO("boil_pump", "false");//stop pumping
				debug("Fake overflow ON for testing purposes");
				gpioCfg.changeStatusIO("led", "true");//fake overflow for testing purposes
			}
			else if(realSpargeTime > 3.5*spargeTimeSetp){//wait until all of the mash is drained
				debug("mash drained, sparging process finished");
				gpioCfg.changeStatusIO("mash_valve", "false");//close the drain valve
				gpioCfg.changeStatusIO("boil_valve", "false");//for security check
				gpioCfg.changeStatusIO("boil_pump", "false");//for security check
				clearInterval(spargeTimer);//stop the current loop
				//theBoil();//that's it? It seems too easy, maybe something is left
			}
		}
		else if(!mashTunOverflow){//while waiting for the first drain to finish
			log.logToFile("sparging in progress", 6);//just log to file, so the current time updates
		}
		if(!mashTunOverflow && global.environmentVariables.ioStatus["led"].state == b.HIGH){//if MT is about to overflow
			debug("Overflow detected, pumping on hold");
			mashTunOverflow = true;//set overflow flag
			gpioCfg.changeStatusIO("boil_pump", "false");//stop pumping
			log.logToFile("mash tun overflow", 7);//log to file that the mash tun is almost overflowing
		}
		else if(mashTunOverflow){//there mey be the need for some hysteresis due to the liquid behavior
			setTimeout(function(){//wait some time before turning the recirculation pump on
				mashTunOverflow = false;
				gpioCfg.changeStatusIO("boil_pump", "true");//this is risky since the pump could be already off before overflow
				debug("Fake overflow OFF for testing purposes");
				gpioCfg.changeStatusIO("led", "false");//fake overflow for testing purposes
			},overflowTimeSetp);
		}
	}, 500);
	
}



function updateHeatingConditions(vessel, setp, temperature, callback){
	//This function must be called in a loop, every loop interation
	if(vessel == "mash_heat" || vessel == "MT" || vessel == "mash tun"){
		vessel = "mash_heat";//if wants to heat the mash tun
		global.environmentVariables.tmpMT = temperature;//update the mash tun temperature
		if(global.environmentVariables.ioStatus["boil_heat"].state == b.HIGH){//security check
			gpioCfg.changeStatusIO("boil_heat", "false");//turn off the other heating element
			debug("Security shutdown of the BK heater");
		}
	}
	else if(vessel == "boil_heat" || vessel == "BK" || vessel == "brewing kettle" || vessel == "copper"){
		vessel = "boil_heat";//if wants to heat the brewing kettle
		global.environmentVariables.tmpBK = temperature;//update the brewing kettle temperature
		if(global.environmentVariables.ioStatus["mash_heat"].state == b.HIGH){//security check
			gpioCfg.changeStatusIO("mash_heat", "false");//turn off the other heating element
			debug("Security shutdown of the MT heater");
		}
	}
	else{//if vessel is unknown
		callback("unknown vessel");
		return;//don't even try to heat
	}
	debug("Heating power variable: " + global.heatingPower);
	if(temperature < 0.7*setp){//if temperature is less then 0.7 of the setpoint
		debug(vessel + ": 100% heating power");
		gpioCfg.changeStatusIO(vessel, "true");//give 100% power to the heating resistor
	}
	else if(temperature < 0.9*setp){//if temperature between 0.7 and 0.9 of the setpoint 
		debug(vessel + ": 66% heating power");
		if(global.heatingPower == 0){//give 66% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "false");// 1/3 of the time off
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "true");// 2/3 of the time on
			global.heatingPower--;
		}
	}
	else if(temperature < setp){//if temperature between 0.9 and 1.0 of the setpoint 
		debug(vessel + ": 33% heating power");
		if(global.heatingPower == 0){//give 33% power to the heating resistor
			gpioCfg.changeStatusIO(vessel, "true");// 1/3 of the time on
			global.heatingPower = 2;// heatingPower goes from 0 to 2
		}
		else{
			gpioCfg.changeStatusIO(vessel, "false");// 2/3 of the time off
			global.heatingPower--;
		}
	}
	else{//in this case, the temperature got to the setpoint
		debug(vessel + ": 0% heating power");
		gpioCfg.changeStatusIO(vessel, "false");// turn the heating element off
		callback(null);//choose what to do
	}
}