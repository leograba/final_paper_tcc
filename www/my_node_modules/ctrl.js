'use strict';

var debug = require('debug')('ctrl');
var fs = require('fs');
var gpioCfg = require('./gpio_cfg.js');
var log = require('./log_check_misc.js');

module.exports.startMashingProcess = function (recipe, res, lockFile, recipesPath, callback){
	/*Starts the mashing process, checking if everything is in order, starting
	the temperature logging and the heating of the mash water.
	The callback function is passed as callback to the heatMashWater function*/
	var serverResponse = {resp:"success"};
	var recipeContents ;
	if(global.environmentVariables.okToStart){//first check is if the recipe is ok to start
		if(recipe == global.environmentVariables.recipe){//recipe name should match also
			fs.writeFile(lockFile, 1, function(err){//write to lockfile telling there is a recipe in progress
				if(err){
					serverResponse.resp = "could not write to lockfile";
					res.send(serverResponse);
					return;
				}
				log.logToFile("production starting", 1);//log to file
				fs.readFile(recipesPath + "/" + global.environmentVariables.recipe, function(err, data){
					if(err){//if file contents could not be retrieved
						serverResponse.resp = "couldn't read recipe file";//tells the client
						res.send(serverResponse);
						return;
					}//if file was successfully read
					log.startTemperatureLogging();
					recipeContents = data.toString("UTF8").split("\n");//split contents to array
					for(var i = 0; i < recipeContents.length; i++){//get only the relevant data
						recipeContents[i] = recipeContents[i].split('"')[1];
					}
					serverResponse.resp = "success";//tells the client everything went alright
					res.send(serverResponse);
					heatMashWater(recipeContents[7], recipeContents[5]);//start to heat the mash water
					callback("fuckme!","Run, baby, run!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
				});
			});
		}
		else{//if recipe name doesn't match the one from "startRequest"
			serverResponse.resp = "failed";
			res.send(serverResponse);
		}
	}
	else{//if recipe isn't ok to start
		serverResponse.resp = "failed";
		res.send(serverResponse);
	}
};

function heatMashWater(mashSetpoint, spargeSetpoint){
	//heats the mashing water to the starting setpoint
	var retStatus = false;//false means fail, true means success
	var heatingPower = 2;
	var instantPath = "./datalog/instant.csv";
	var lockFile = "./datalog/lockfile";//file that tells if recipe is running
	var errorCount = 0;//counts the file reading errors
	var lastReadingsTimestamp = [0, 0, 0, 0, 0];//last 5 timestamps, to check if readings are going ok
	var lastValidTemperature = 0;//the last valid temperature reading (defaults to zero, not the better solution)
	var reachedSetpoint = false;//var set to true the first time the checkpoint is reached
	global.environmentVariables.tmpMTsetp = mashSetpoint;//stores the setpoints
	global.environmentVariables.tmpBKsetp = spargeSetpoint;
	gpioCfg.changeStatusIO("mash_pump", "true");//turn the recirculation pump on
	
	var logTimer = setInterval(function(){//logs the heating process every ~5s
		log.logToFile("heating mash water", 2);//log to file
	}, 5000);
	var readTmpTimer = setInterval(function(){//read temperature every second
		fs.readFile(instantPath, "utf-8" ,function(err, data){//gets the most recent temperature reading
		var parsedData ;//variable to hold the relevant data (temperature and its timestamp)
			if(err){//could not read temperature
				errorCount++;//increment the errorCount variable
				if(errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
					//oh my god thigs are bad! User, you must take over from here
					retStatus = false;//return error
					debug("Too many temperature reading errors, something may be going awry!");
				}
			}
			else{//if temperature reading from file was successful
				parsedData = data.trim().split('\n').slice(-1)[0].split(',');
				if((parsedData[0] == "temperature") || (typeof parsedData[0] != "string") || isNaN(+parsedData[0])){//wrong reading beacuse of wrong logging
					debug("Wrong temperature reading: " + parsedData[0]);
					parsedData[0] = lastValidTemperature;//then use the last valid temperature reading
					errorCount++;//increment the errorCount variable
					if(errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
						//oh my god thigs are bad! User, you must take over from here
						retStatus = false;//return error
						debug("Too many temperature reading errors, something may be going awry!");
					}
				}
				else{
					parsedData[0] = +parsedData[0];//string to number
					lastValidTemperature = +parsedData[0];//save the last valid temperature reading
				}
				lastReadingsTimestamp[4] = parsedData[1];//updates last temperature reading timestamp
				for(var i = 0; i < 4; i++){//updates the older timestamps also
					lastReadingsTimestamp[i] = lastReadingsTimestamp[i+1];
				}
				if(lastReadingsTimestamp[0] >= lastReadingsTimestamp[4]){//if the reading is the same within 4s
					debug("Log not updating, check temperature probe connection!");
					errorCount++;//increment the errorCount variable
					if(errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
						//oh my god thigs are bad! User, you must take over from here
						retStatus = false;//return error
						debug("Too many temperature reading errors, something may be going awry!");
					}
					//hey user check this, because something may be going awry!
				}
				else{//then we can act in order to get to the temperature setpoint
					global.environmentVariables.tmpMT = parsedData[0];//update the mash tun temperature
					debug(typeof parsedData[0]);
					if(parsedData[0] < 0.7*mashSetpoint){//if temperature is less then 0.7 of the setpoint
						gpioCfg.changeStatusIO("mash_heat", "true");//give 100% power to the heating resistor
					}
					else if(parsedData[0] < 0.9*mashSetpoint){//if temperature between 0.7 and 0.9 of the setpoint 
						if(heatingPower == 0){//give 66% power to the heating resistor
							gpioCfg.changeStatusIO("mash_heat", "false");// 1/3 of the time off
							heatingPower = 2;// heatingPower goes from 0 to 2
						}
						else{
							gpioCfg.changeStatusIO("mash_heat", "true");// 2/3 of the time on
							heatingPower--;
							
						}
					}
					else if(parsedData[0] < mashSetpoint){//if temperature between 0.9 and 1.0 of the setpoint 
						if(heatingPower == 0){//give 33% power to the heating resistor
							gpioCfg.changeStatusIO("mash_heat", "true");// 1/3 of the time on
							heatingPower = 2;// heatingPower goes from 0 to 2
						}
						else{
							gpioCfg.changeStatusIO("mash_heat", "false");// 2/3 of the time off
							heatingPower--;
							
						}
					}
					else{//in this case, the temperature got to the setpoint
						//should everything be turned off or should it try to keep the temperature?
						if(!reachedSetpoint){//if it is the first time the setpoint is reached
							debug('Setpoint reached. Now the user must add the grains.');
							reachedSetpoint = true;//holds this information
							clearInterval(logTimer);//stop the logging
							log.logToFile("waiting for grains", 3);//log to file at least once
							logTimer = setInterval(function(){//logs that system is waiting for user input
								log.logToFile("waiting for grains", 3);//log to file
							}, 5000);
							log.stopTemperatureLogging();//kill the process and stop logging (for tests only)
							//send message to the user and wait for him to add the grains
						}
						//just do the next things after the user added the grains
						clearInterval(logTimer);//stop the "waiting for grains" logging (just for testing purposes)
						fs.writeFile(lockFile, 0, function(err){//release the lock (just for testing purposes)
							if(err){
								//serverResponse.resp = "could not write to lockfile";
							}
						});
						gpioCfg.changeStatusIO("mash_pump", "false");//turn the recirculation pump off
						gpioCfg.changeStatusIO("mash_heat", "false");//turn the heating element off
						//clearInterval(readTmpTimer);//stop the temperature adjusting loop
						//log.stopTemperatureLogging();//kill the process and stop logging (for tests only)
						debug(	"    Heating of the mash water finished\n"
								+ "            Temperature = " + parsedData[0]
								+ "            Reading errors = " + errorCount);
						//tell the user he must add the grains to the water
						//return happily ever after
						clearInterval(readTmpTimer);//do it only after user acknowlegde about adding the grains (return anyway for testing purposes)
						retStatus = true;//do it only after user acknowlegde about adding the grains (return anyway for testing purposes)
					}
				}
			}
		});
	},1000);
	return retStatus;
}