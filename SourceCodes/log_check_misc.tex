\lstset{language=javascript}
\begin{lstlisting}[frame=single, basicstyle=\linespread{0.85}\ttfamily, caption=Módulo de registros e verificações em geral, label=log_check_misc_js]
'use strict';

var debug = require('debug')('log');
var fs = require('fs');
var spawn = require("child_process").spawn;

//variables
var temperatureLogHandler;//variable to handle the python "log.py" script
		
module.exports.startTemperatureLogging = function (){
	//starts the python script that logs temperature to file
	//sudo kill $(ps aux | grep log.py | grep -v grep | awk '{print $2}') //to stop the process from terminal
	fs.unlink("./datalog/instant.csv", function(err){//try to delete the old last saved value
		if(err){//this may happen if the old log was already deleted
			debug("file could not be deleted!");//probably nothing to worry about
		}
		//start the logging process anyway
		temperatureLogHandler = spawn("python", ["/home/debian/brewing/log_test.py"]);//starts to log
		debug("Temperature logging started!");
		temperatureLogHandler.on('close', function(code, signal){
	        debug("Temperature logging stopped!");
        });
	});
};

module.exports.stopTemperatureLogging = function(){
    debug("Stopping the temperature logging!");
    temperatureLogHandler.kill('SIGHUP');//kill the process and stop logging
};

module.exports.getTemperatureReading = function (logFilePath, logReadHandler, callback){
//	var logReadHandler = {
//		lastValidTemperature: 0,//the last valid temperature reading (defaults to zero, not the better solution)
//		lastReadingsTimestamp: [0, 0, 0, 0, 0],//last 5 timestamps, to check if readings are going ok
//		errorCount: 0//counts the file reading errors
//	};
	fs.readFile(logFilePath, "utf-8" ,function(err, data){//gets the most recent temperature reading
		var parsedData ;//variable to hold the relevant data (temperature and its timestamp)
		var callbackError;
		if(err){//could not read temperature
			logReadHandler.errorCount++;//increment the errorCount variable
			if(logReadHandler.errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
				//oh my god thigs are bad! User, you must take over from here
				callbackError = "Too many temperature reading errors, something may be going awry!";
				debug("Too many temperature reading errors, something may be going awry!");
				callback(err, null);
			}
			else{
				callbackError = "Single wrong reading, nothing to worry yet.";
				debug("Single wrong reading, nothing to worry yet.");
				callback(err, null);
			}
		}
		else{//if temperature reading from file was successful
			parsedData = data.trim().split('\n').slice(-1)[0].split(',');
			if((parsedData[0] == "temperature") || (typeof parsedData[0] != "string") || isNaN(+parsedData[0])){//wrong reading beacuse of wrong logging
				debug("Wrong temperature reading: " + parsedData[0]);
				parsedData[0] = logReadHandler.lastValidTemperature;//then use the last valid temperature reading
				logReadHandler.errorCount++;//increment the errorCount variable
				if(logReadHandler.errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
					//oh my god thigs are bad! User, you must take over from here
					callbackError = "Too many temperature reading errors, something may be going awry!";
					debug("Too many temperature reading errors, something may be going awry!");
					callback(err, null);
				}
				else{
					callbackError = "Single wrong reading, nothing to worry yet.";
					debug("Single wrong reading, nothing to worry yet.");
					callback(err, null);
				}
			}
			else{
				parsedData[0] = +parsedData[0];//string to number
				logReadHandler.lastValidTemperature = +parsedData[0];//save the last valid temperature reading
			}
			logReadHandler.lastReadingsTimestamp[4] = parsedData[1];//updates last temperature reading timestamp
			for(var i = 0; i < 4; i++){//updates the older timestamps also
				logReadHandler.lastReadingsTimestamp[i] = logReadHandler.lastReadingsTimestamp[i+1];
			}
			if(logReadHandler.lastReadingsTimestamp[0] >= logReadHandler.lastReadingsTimestamp[4]){//if the reading is the same within 4s
				//hey user check this, because something may be going awry!
				callbackError = "Log not updating, check temperature probe connection!";
				debug("Log not updating, check temperature probe connection!");
				logReadHandler.errorCount++;//increment the errorCount variable
				if(logReadHandler.errorCount >= 180){//180 arbitrarily chosen - it is 5% of 1 hour logging readings
					//oh my god thigs are bad! User, you must take over from here
					callbackError = "Too many temperature reading errors, something may be going awry!";
					debug("Too many temperature reading errors, something may be going awry!");
				}
				callback(err, null);
			}
			else{//then we can act in order to get to the temperature setpoint
			//callback second argument is the temperature
			callback(null, parsedData[0]);//successfully got the temperature reading
			}
		}
	});
};

module.exports.checkRecipeIntegrity = function (recipe, path, res){
	var serverResponse = {resp: "success", warn: "", err: ""};//tells the client if everything is ok
	var recipeContents ;
	global.environmentVariables.recipe = recipe;//save the recipe name
	fs.readFile(path + "/" + recipe, function(err, recipeFileContents){
		var okToStartFlag = 1;
		if(err){//if file contents could not be retrieved
			serverResponse.resp = "couldntReadFile";//tells the client
			res.send(serverResponse);
		}
		else{///if file was successfully read
			fs.readFile("./datalog/lockfile", function(err, lockFileContents){
				if(err){//if lockfile could not be read for some reason
					serverResponse.resp = err;
					//res.send(serverResponse);
					okToStartFlag = 0;//unable to start the recipe
					debug("couldn't read lockfile, unable to start recipe.");
					return;
				}
				if(+lockFileContents == 0){//if there is no recipe in progress
					debug("ready to rock!");
					recipeContents = recipeFileContents.toString("UTF8").split("\n");//split contents to array
					for(var i = 0; i < recipeContents.length; i++){//get only the relevant data
						recipeContents[i] = recipeContents[i].split('"')[1];
						if(!recipeContents[i]){//if some recipe line is blank
							switch(i){//and this line is important, then:
								case 0://recipe name not set (warning)
									serverResponse.warn += "nome da receita; ";
									break;
								case 1://beer style not set (warning)
									serverResponse.warn += "estilo; ";
									break;
								case 2://beer yeast not set (warning)
									serverResponse.warn += "levedura; ";
									break;
								case 3://mash water not set (error)
									serverResponse.err += "água de brassagem; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 4://sparging water not set (warning)
									serverResponse.warn += "água de sparging; ";
									break;
								case 5://sparging water temperature not set (warning)
									serverResponse.warn += "temperatura de sparging; ";
									break;
								case 6://boiling time not set (error)
									serverResponse.err += "tempo da fervura; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 7://mash initial temperature not set (error)
									serverResponse.err += "temperatura inicial de brassagem; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 8://mash first step not set (error)
									serverResponse.err += "primeiro degrau de temperatura; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 9://mash first step time not set (error)
									serverResponse.err += "tempo do primeiro degrau; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 24://malt 1 not set (error)
									serverResponse.err += "malte 1; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 25://malt 1 quantity not set (error)
									serverResponse.err += "quantidade do malte 1; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 40://hop 1 not set (error)
									serverResponse.err += "lúpulo 1; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 41://hop 1 quantity not set (error)
									serverResponse.err += "quantidade do lúpulo 1; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
								case 42://hop 1 adding time not set (error)
									serverResponse.err += "tempo de adição do lúpulo 1; ";
									global.environmentVariables.okToStart = false;
									okToStartFlag = 0;
									break;
							}
						}
					}
					if(okToStartFlag){//if recipe can be started
						global.environmentVariables.okToStart = true;//add this info to the global variables
					}
					logToFile("request to start production", 0, "start");
					res.send(serverResponse);//answer to the client (may have error msg or not)
					debug(serverResponse);
				}
				else{//there is a recipe in progress, cannot start
					//okToStartFlag = 0;
					serverResponse.resp = "recipe in progress. Unable to start mashing";
					res.send(serverResponse);//answer error to the client
				}
			});
		}
	});
};

var logToFile = module.exports.logToFile = function (message, code, notableTimestamp){
	var d = new Date();
	var logTime = d.getTime();
	var dataToSave ;
	var logFile = "./datalog/backup.log";//path to the backup logs file
	global.environmentVariables.msg = message;//explanatory message to be logged
	global.environmentVariables.code = code;//code referring to the message
	global.environmentVariables.timestamps.curr = logTime;//logs the request to start recipe timestamp
	if(notableTimestamp in global.environmentVariables.timestamps){//checks if variable is declared
		debug(notableTimestamp + " is declared. Logging notable timestamp");
		global.environmentVariables.timestamps[notableTimestamp] = logTime;
	}
	//global.environmentVariables.ioStatus = gpioCfg.all_io;//all of the pins status
	//the above commented line may not be needed since the main script attributes one variable to the other 
	//and so one variable points to the other, not needing to refresh it. *They are pointers, not values!
	dataToSave = JSON.stringify(global.environmentVariables) + "\n";
	debug(global.environmentVariables.msg + " - code: " + global.environmentVariables.code + " - auto: " + global.environmentVariables.auto);
	if(code == 0){//if it is the first line to be logged, overwrite log file
		fs.writeFile(logFile, dataToSave, function(err){//overrwite previous backup
			if(err){//if was unable to log to the file
				debug("could not write to the backup file!");//well my friend, you're on your own!
			}
			else{
				debug("backup log started!");
			}
		});
	}
	else{//otherwise, just append the data
		fs.appendFile(logFile, dataToSave, function(err){//overrwite previous backup
			if(err){//if was unable to log to the file
				debug("could not write to the backup file!");//well my friend, you're on your own!
			}
			else{
				debug("backup log updated!");
			}
		});
	}
};

module.exports.sendRecipeNames = function (path, res){//try to read files in directory
	fs.readdir(path, function(err,files){
		var deletedIndexes = new Array();// variable that holds the indexes of the deleted recipes
		var serverResponse = {resp:"success"};
		if(err){//if something is wrong
			debug(err);//print the error
			serverResponse.resp = "error";
			serverResponse.recipes = err;
		}
		else{
			for(var i = 0; i < files.length; i++){//iterate the array of names
				if(files[i].indexOf(".del") > 0){//if the server reads a deleted file
					deletedIndexes.push(i);
				}
				files[i] = files[i].replace(".recipe", "");//remove the file extension
				files[i] = files[i].replace(/_/g, " ");//replace underlines with spaces
			}
			for(i = (deletedIndexes.length)-1; i >= 0;  i--){//iterate the array of deleted recipes
				//debug("index: " + deletedIndexes[i]);
				files.splice(deletedIndexes[i],1);//deletes the file name from the array
			}
			debug("deleted recipes indexes: " + deletedIndexes);
			serverResponse.recipes = files;
		}
		res.send(serverResponse);//send the recipes if successful, otherwise sends the error
	});//get it and return to the client
};
\end{lstlisting}
